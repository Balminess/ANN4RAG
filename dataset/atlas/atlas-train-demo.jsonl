{"focal_method": "toString ( ) { if ( ( stringValue ) == null ) stringValue = decode ( com . beijunyi . parallelgit . filesystem . CHARSET , path ) ; return stringValue ; }", "test_method": "resolveRootPathFromAbsolutePathTest ( ) { com . beijunyi . parallelgit . filesystem . GitPath parent = gfs . getPath ( \"/parent/dir\" ) ; com . beijunyi . parallelgit . filesystem . GitPath path = parent . resolve ( \"/\" ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( \"/\" , path . toString ( ) )", "method_name": "toString", "test_name": "resolveRootPathFromAbsolutePathTest"}
{"focal_method": "init ( java . util . Properties ) { java . lang . String dp = config . getProperty ( org . jitsi . dnssec . validator . ValUtils . DIGEST_PREFERENCE ) ; if ( dp != null ) { java . lang . String [ ] dpdata = dp . split ( \",\" ) ; this . digestPreference = new int [ dpdata . length ] ; for ( int i = 0 ; i < ( dpdata . length ) ; i ++ ) { this . digestPreference [ i ] = java . lang . Integer . parseInt ( dpdata [ i ] ) ; if ( ! ( org . jitsi . dnssec . validator . ValUtils . isDigestSupported ( this . digestPreference [ i ] ) ) ) { throw new java . lang . IllegalArgumentException ( \"Unsupported<sp>digest<sp>ID<sp>in<sp>digest<sp>preferences\" ) ; } } } }", "test_method": "testFavoriteDigestNotInRRset ( ) { java . util . Properties config = new java . util . Properties ( ) ; config . put ( \"org.jitsi.dnssec.digest_preference\" , \"4\" ) ; org . jitsi . dnssec . validator . ValUtils v = new org . jitsi . dnssec . validator . ValUtils ( ) ; v . init ( config ) ; org . jitsi . dnssec . SRRset set = new org . jitsi . dnssec . SRRset ( ) ; set . addRR ( new org . xbill . DNS . DSRecord ( org . xbill . DNS . Name . root , org . xbill . DNS . DClass . IN , 120 , 1234 , org . xbill . DNS . DNSSEC . Algorithm . DSA , org . xbill . DNS . DSRecord . Digest . SHA1 , new byte [ ] { 1 , 2 , 3 } ) ) ; set . addRR ( new org . xbill . DNS . DSRecord ( org . xbill . DNS . Name . root , org . xbill . DNS . DClass . IN , 120 , 1234 , org . xbill . DNS . DNSSEC . Algorithm . DSA , org . xbill . DNS . DSRecord . Digest . SHA256 , new byte [ ] { 1 , 2 , 3 } ) ) ; int digestId = org . powermock . reflect . Whitebox . invokeMethod ( v , \"favoriteDSDigestID\" , set ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( 0 , digestId )", "method_name": "init", "test_name": "testFavoriteDigestNotInRRset"}
{"focal_method": "execAndAssert ( com . meterware . httpunit . WebRequest , java . lang . String ) { com . meterware . httpunit . WebResponse rsp = sc . getResponse ( request ) ; org . junit . Assert . assertEquals ( HttpStatus . SC_OK , rsp . getResponseCode ( ) ) ; final java . lang . String text = rsp . getText ( ) ; org . junit . Assert . assertTrue ( text . startsWith ( \"REQUESTLINE:\" ) ) ; java . lang . String expectedTargetUri = getExpectedTargetUri ( request , expectedUri ) ; java . lang . String expectedFirstLine = \"REQUESTLINE:<sp>\" + ( request instanceof com . meterware . httpunit . GetMethodWebRequest ? \"GET\" : \"POST\" ) ; expectedFirstLine += ( \"<sp>\" + expectedTargetUri ) + \"<sp>HTTP/1.1\" ; java . lang . String firstTextLine = text . substring ( 0 , text . indexOf ( java . lang . System . getProperty ( \"line.separator\" ) ) ) ; org . junit . Assert . assertEquals ( expectedFirstLine , firstTextLine ) ; java . util . Dictionary headers = request . getHeaders ( ) ; java . util . Enumeration headerNameEnum = headers . keys ( ) ; while ( headerNameEnum . hasMoreElements ( ) ) { java . lang . String headerName = ( ( java . lang . String ) ( headerNameEnum . nextElement ( ) ) ) ; org . junit . Assert . assertTrue ( text . contains ( headerName ) ) ; } return rsp ; }", "test_method": "testPreserveHost ( ) { servletRunner = new com . meterware . servletunit . ServletRunner ( ) ; java . util . Properties servletProps = new java . util . Properties ( ) ; servletProps . setProperty ( \"http.protocol.handle-redirects\" , \"false\" ) ; servletProps . setProperty ( ProxyServlet . P_LOG , \"true\" ) ; servletProps . setProperty ( ProxyServlet . P_FORWARDEDFOR , \"true\" ) ; servletProps . setProperty ( ProxyServlet . P_PRESERVEHOST , \"true\" ) ; setUpServlet ( servletProps ) ; sc = servletRunner . newClient ( ) ; sc . getClientProperties ( ) . setAutoRedirect ( false ) ; final java . lang . String HEADER = \"Host\" ; final java . lang . String [ ] proxyHost = new java . lang . String [ 1 ] ; localTestServer . register ( \"/targetPath*\" , new org . mitre . dsmiley . httpproxy . ProxyServletTest . RequestInfoHandler ( ) { public void handle ( org . apache . http . HttpRequest request , org . apache . http . HttpResponse response , org . apache . http . protocol . HttpContext context ) throws java . io . IOException , org . apache . http . HttpException { proxyHost [ 0 ] = request . getHeaders ( HEADER ) [ 0 ] . getValue ( ) ; super . handle ( request , response , context ) ; } } ) ; com . meterware . httpunit . GetMethodWebRequest req = makeGetMethodRequest ( sourceBaseUri ) ; req . setHeaderField ( HEADER , \"SomeHost\" ) ; execAndAssert ( req , \"\" ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( \"SomeHost\" , proxyHost [ 0 ] )", "method_name": "execAndAssert", "test_name": "testPreserveHost"}
{"focal_method": "add ( long [ ] ) { for ( long oneLong : dat ) { addLong ( oneLong ) ; } }", "test_method": "equalTest1 ( ) { org . roaringbitmap . Container ac = new org . roaringbitmap . ArrayContainer ( ) ; org . roaringbitmap . Container ar = new org . roaringbitmap . RunContainer ( ) ; for ( int k = 0 ; k < 100 ; ++ k ) { ac = ac . add ( ( ( short ) ( k * 10 ) ) ) ; ar = ar . add ( ( ( short ) ( k * 10 ) ) ) ; } \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( ac , ar )", "method_name": "add", "test_name": "equalTest1"}
{"focal_method": "findIds ( ) { new org . tests . model . cache . EColAB ( \"03\" , \"someId\" ) . save ( ) ; new org . tests . model . cache . EColAB ( \"04\" , \"someId\" ) . save ( ) ; new org . tests . model . cache . EColAB ( \"05\" , \"someId\" ) . save ( ) ; org . ebeantest . LoggedSqlCollector . start ( ) ; java . util . List < java . lang . Integer > colA_first = io . ebean . Ebean . find ( org . tests . model . cache . EColAB . class ) . setUseQueryCache ( CacheMode . ON ) . where ( ) . eq ( \"columnB\" , \"someId\" ) . findIds ( ) ; java . util . List < java . lang . Integer > colA_second = io . ebean . Ebean . find ( org . tests . model . cache . EColAB . class ) . setUseQueryCache ( CacheMode . ON ) . where ( ) . eq ( \"columnB\" , \"someId\" ) . findIds ( ) ; java . util . List < java . lang . String > sql = org . ebeantest . LoggedSqlCollector . stop ( ) ; assertThat ( colA_first ) . isSameAs ( colA_second ) ; assertThat ( colA_first ) . hasSize ( 3 ) ; assertThat ( sql ) . hasSize ( 1 ) ; org . ebeantest . LoggedSqlCollector . start ( ) ; colA_second = io . ebean . Ebean . find ( org . tests . model . cache . EColAB . class ) . setUseQueryCache ( CacheMode . PUT ) . where ( ) . eq ( \"columnB\" , \"someId\" ) . findIds ( ) ; sql = org . ebeantest . LoggedSqlCollector . stop ( ) ; assertThat ( sql ) . hasSize ( 1 ) ; }", "test_method": "testQuery ( ) { org . tests . model . basic . Truck truck = new org . tests . model . basic . Truck ( ) ; truck . setLicenseNumber ( \"TK123\" ) ; io . ebean . Ebean . save ( truck ) ; java . util . List < java . lang . Integer > ids = io . ebean . Ebean . find ( org . tests . model . basic . Vehicle . class ) . findIds ( ) ; \"<AssertPlaceHolder>\" ; io . ebean . Ebean . delete ( truck ) ; }", "assertion": "org . junit . Assert . assertNotNull ( ids )", "method_name": "findIds", "test_name": "testQuery"}
{"focal_method": "getFile ( java . lang . String ) { org . eclipse . linuxtools . internal . perf . model . PMFile tmp = ( ( org . eclipse . linuxtools . internal . perf . model . PMFile ) ( getChild ( fileName ) ) ) ; if ( tmp != null ) { } else { tmp = new org . eclipse . linuxtools . internal . perf . model . PMFile ( fileName ) ; addChild ( tmp ) ; } return tmp ; }", "test_method": "testShortcutEditor ( ) { org . eclipse . linuxtools . internal . valgrind . helgrind . tests . ValgrindTestHelgrindLaunchShortcut shortcut = new org . eclipse . linuxtools . internal . valgrind . helgrind . tests . ValgrindTestHelgrindLaunchShortcut ( ) ; org . eclipse . ui . IWorkbenchPage page = org . eclipse . ui . PlatformUI . getWorkbench ( ) . getActiveWorkbenchWindow ( ) . getActivePage ( ) ; org . eclipse . core . resources . IFile file = proj . getProject ( ) . getFile ( \"test.c\" ) ; org . eclipse . ui . IEditorPart editor = org . eclipse . ui . ide . IDE . openEditor ( page , file ) ; \"<AssertPlaceHolder>\" ; shortcut . launch ( editor , ILaunchManager . PROFILE_MODE ) ; org . eclipse . debug . core . ILaunchConfiguration config = shortcut . getConfig ( ) ; compareWithDefaults ( config ) ; }", "assertion": "org . junit . Assert . assertNotNull ( editor )", "method_name": "getFile", "test_name": "testShortcutEditor"}
{"focal_method": "serialised ( java . lang . Object ) { java . lang . Object result = null ; java . io . ByteArrayOutputStream buffer = new java . io . ByteArrayOutputStream ( ) ; java . io . ObjectOutput out ; try { out = new java . io . ObjectOutputStream ( buffer ) ; out . writeObject ( original ) ; out . close ( ) ; java . io . ObjectInput in = new java . io . ObjectInputStream ( new java . io . ByteArrayInputStream ( buffer . toByteArray ( ) ) ) ; result = in . readObject ( ) ; in . close ( ) ; } catch ( java . io . IOException e ) { throw new java . lang . RuntimeException ( e ) ; } catch ( java . lang . ClassNotFoundException e ) { throw new java . lang . RuntimeException ( e ) ; } return result ; }", "test_method": "testSerialization ( ) { org . jfree . chart . labels . StandardXYItemLabelGenerator g1 = new org . jfree . chart . labels . StandardXYItemLabelGenerator ( ) ; org . jfree . chart . labels . StandardXYItemLabelGenerator g2 = ( ( org . jfree . chart . labels . StandardXYItemLabelGenerator ) ( org . jfree . chart . TestUtils . serialised ( g1 ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( g1 , g2 )", "method_name": "serialised", "test_name": "testSerialization"}
{"focal_method": "getInstance ( org . eclipse . rap . rwt . service . UISession ) { return ( ( org . eclipse . rap . rwt . internal . SingletonManager ) ( uiSession . getAttribute ( org . eclipse . rap . rwt . internal . SingletonManager . ATTR_SINGLETON_MANAGER ) ) ) ; }", "test_method": "testGetInstance_uiSession_nullIfNotInstalled ( ) { org . eclipse . rap . rwt . internal . SingletonManager singletonManager = org . eclipse . rap . rwt . internal . SingletonManager . getInstance ( uiSession ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertNull ( singletonManager )", "method_name": "getInstance", "test_name": "testGetInstance_uiSession_nullIfNotInstalled"}
{"focal_method": "getEvaluations ( ) { return evaluations ; }", "test_method": "shouldGetEvaluations ( ) { org . springframework . test . util . ReflectionTestUtils . setField ( algorithm , \"evaluations\" , 15 ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( 15 , algorithm . getEvaluations ( ) )", "method_name": "getEvaluations", "test_name": "shouldGetEvaluations"}
{"focal_method": "getHeaderWordWrap ( ) { checkWidget ( ) ; return headerWordWrap ; }", "test_method": "testGetHeaderWordWrap_Initial ( ) { \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertFalse ( group . getHeaderWordWrap ( ) )", "method_name": "getHeaderWordWrap", "test_name": "testGetHeaderWordWrap_Initial"}
{"focal_method": "getCurrentSession ( ) { return sessionFactory . getCurrentSession ( ) ; }", "test_method": "fetchModeSelectCriteria ( ) { persistBooks ( ( ) -> new com . example . entities . BookFetchModeSelect ( ) ) ; System . out . println ( \"FetchMode.SELECT<sp>Criteria<sp>API\" ) ; java . util . List books = getCurrentSession ( ) . createCriteria ( com . example . entities . BookFetchModeSelect . class ) . list ( ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( 4 , books . size ( ) )", "method_name": "getCurrentSession", "test_name": "fetchModeSelectCriteria"}
{"focal_method": "size ( ) { return entries . size ( ) ; }", "test_method": "testJsonEmpty0 ( ) { com . questdb . net . http . QueryResponse queryResponse = com . questdb . net . http . handlers . QueryHandlerTest . download ( \"tab<sp>where<sp>1<sp>=<sp>2\" , 0 , 0 ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( 0 , queryResponse . dataset . size ( ) )", "method_name": "size", "test_name": "testJsonEmpty0"}
{"focal_method": "create ( java . lang . Object ) { return clone ( value ) ; }", "test_method": "testCreate ( ) { com . streamsets . pipeline . api . impl . IntegerTypeSupport ts = new com . streamsets . pipeline . api . impl . IntegerTypeSupport ( ) ; int o = 1 ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertSame ( o , ts . create ( o ) )", "method_name": "create", "test_name": "testCreate"}
{"focal_method": "equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . jfree . data . xy . YWithXInterval ) ) { return false ; } org . jfree . data . xy . YWithXInterval that = ( ( org . jfree . data . xy . YWithXInterval ) ( obj ) ) ; if ( ( this . y ) != ( that . y ) ) { return false ; } if ( ( this . xLow ) != ( that . xLow ) ) { return false ; } if ( ( this . xHigh ) != ( that . xHigh ) ) { return false ; } return true ; }", "test_method": "testEquals ( ) { org . jfree . data . time . Month m1 = new org . jfree . data . time . Month ( org . jfree . chart . date . MonthConstants . MAY , 2002 ) ; org . jfree . data . time . Month m2 = new org . jfree . data . time . Month ( org . jfree . chart . date . MonthConstants . MAY , 2002 ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertTrue ( m1 . equals ( m2 ) )", "method_name": "equals", "test_name": "testEquals"}
{"focal_method": "getMetaDataSet ( ) { return java . util . Collections . unmodifiableSet ( metaDataSet ) ; }", "test_method": "testUploadImageAndMetaData ( ) { com . github . tobato . fastdfs . service . FastFileStorageNewImageClientTest . LOGGER . debug ( \"##..##\" ) ; com . github . tobato . fastdfs . domain . upload . FastImageFile fastImageFile = crtFastImageFileOnly ( ) ; com . github . tobato . fastdfs . domain . fdfs . StorePath path = uploadImageAndCrtThumbImage ( fastImageFile ) ; com . github . tobato . fastdfs . service . FastFileStorageNewImageClientTest . LOGGER . debug ( \"{}\" , path ) ; com . github . tobato . fastdfs . service . FastFileStorageNewImageClientTest . LOGGER . debug ( \"##Metadata##\" ) ; java . util . Set < com . github . tobato . fastdfs . domain . fdfs . MetaData > fetchMetaData = storageClient . getMetadata ( path . getGroup ( ) , path . getPath ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( fetchMetaData , fastImageFile . getMetaDataSet ( ) )", "method_name": "getMetaDataSet", "test_name": "testUploadImageAndMetaData"}
{"focal_method": "getFaults ( ) { return _faults . toArray ( new com . persistit . IntegrityCheck . Fault [ _faults . size ( ) ] ) ; }", "test_method": "testBrokenMVVs ( ) { final com . persistit . Exchange ex = _persistit . getExchange ( _volumeName , \"mvv\" , true ) ; disableBackgroundCleanup ( ) ; transactionalStore ( ex ) ; corrupt2 ( ex ) ; final com . persistit . IntegrityCheck icheck = icheck ( ) ; icheck . checkTree ( ex . getTree ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertTrue ( ( ( icheck . getFaults ( ) . length ) > 0 ) )", "method_name": "getFaults", "test_name": "testBrokenMVVs"}
{"focal_method": "getPost ( java . lang . Integer ) { org . jooq . Record record = dsl . select ( ) . from ( com . apress . demo . services . POSTS ) . where ( POSTS . ID . eq ( postId ) ) . fetchOne ( ) ; if ( record != null ) { com . apress . demo . entities . Post post = getPostEntity ( record ) ; org . jooq . Result < org . jooq . Record > commentRecords = dsl . select ( ) . from ( com . apress . demo . services . COMMENTS ) . where ( COMMENTS . POST_ID . eq ( postId ) ) . fetch ( ) ; for ( org . jooq . Record r : commentRecords ) { post . addComment ( getCommentEntity ( r ) ) ; } return post ; } return null ; }", "test_method": "findPostById ( ) { com . apress . demo . entities . Post post = postService . getPost ( 1 ) ; \"<AssertPlaceHolder>\" ; System . out . println ( post ) ; java . util . List < com . apress . demo . entities . Comment > comments = post . getComments ( ) ; System . out . println ( comments ) ; }", "assertion": "org . junit . Assert . assertNotNull ( post )", "method_name": "getPost", "test_name": "findPostById"}
{"focal_method": "parseInt ( byte [ ] , int ) { final int size = ( Integer . SIZE ) / ( Byte . SIZE ) ; final int len = ( b . length ) - off ; if ( len >= size ) { return com . amazonaws . encryptionsdk . internal . PrimitivesParser . getInt ( b , off ) ; } else { throw new com . amazonaws . encryptionsdk . exception . ParseException ( \"Not<sp>enough<sp>bytes<sp>to<sp>parse<sp>an<sp>integer.\" ) ; } }", "test_method": "testParseInt ( ) { final int [ ] tests = new int [ ] { Integer . MIN_VALUE , Integer . MAX_VALUE , - 1 , 0 , 1 , ( Integer . MIN_VALUE ) + 1 , ( Integer . MAX_VALUE ) - 1 } ; for ( int x : tests ) { try ( final java . io . ByteArrayOutputStream baos = new java . io . ByteArrayOutputStream ( ) ; final java . io . DataOutputStream dos = new java . io . DataOutputStream ( baos ) ) { dos . writeInt ( x ) ; dos . close ( ) ; \"<AssertPlaceHolder>\" ; } } }", "assertion": "org . junit . Assert . assertEquals ( x , com . amazonaws . encryptionsdk . internal . PrimitivesParser . parseInt ( baos . toByteArray ( ) , 0 ) )", "method_name": "parseInt", "test_name": "testParseInt"}
{"focal_method": "getData ( ) { if ( ( ( trimmable ) != null ) && ( ! ( trimmable . booleanValue ( ) ) ) ) { throw new java . lang . IllegalStateException ( \"content<sp>is<sp>not<sp>trimmable\" ) ; } if ( ( writer ) != null ) { writer . flush ( ) ; } if ( ( outputStream ) != null ) { outputStream . flush ( ) ; } return buffer . toByteArray ( ) ; }", "test_method": "getOutputStreamAndGetDataButGetStreamFirst ( ) { de . blizzy . documentr . web . filter . TrimResponseWrapper wrapper = new de . blizzy . documentr . web . filter . TrimResponseWrapper ( response ) ; byte [ ] data = \"hello<sp>â‚¬\" . getBytes ( Charsets . UTF_8 ) ; javax . servlet . ServletOutputStream out = null ; try { out = wrapper . getOutputStream ( ) ; wrapper . setContentType ( \"text/plain\" ) ; out . write ( data ) ; } finally { de . blizzy . documentr . util . Util . closeQuietly ( out ) ; } \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertTrue ( java . util . Arrays . equals ( data , wrapper . getData ( ) ) )", "method_name": "getData", "test_name": "getOutputStreamAndGetDataButGetStreamFirst"}
{"focal_method": "size ( ) { return loggers . size ( ) ; }", "test_method": "testGetEntitiesByWindows ( ) { context . setEntityType ( TimelineEntityType . YARN_CONTAINER . toString ( ) ) ; timelineReader . serviceInit ( conf ) ; org . apache . hadoop . yarn . server . timelineservice . reader . TimelineDataToRetrieve dataToRetrieve = new org . apache . hadoop . yarn . server . timelineservice . reader . TimelineDataToRetrieve ( ) ; java . util . Set < org . apache . hadoop . yarn . api . records . timelineservice . TimelineEntity > actualEntities = timelineReader . getEntities ( context , new org . apache . hadoop . yarn . server . timelineservice . reader . TimelineEntityFilters . Builder ( ) . createdTimeBegin ( 1533985554927L ) . createTimeEnd ( 1533985554927L ) . build ( ) , dataToRetrieve ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( 1 , actualEntities . size ( ) )", "method_name": "size", "test_name": "testGetEntitiesByWindows"}
{"focal_method": "deserialize ( io . katharsis . resource . information . ResourceInformation , java . util . Map ) { io . katharsis . queryspec . QuerySpec rootQuerySpec = new io . katharsis . queryspec . QuerySpec ( resourceInformation . getResourceClass ( ) ) ; setupDefaults ( rootQuerySpec ) ; java . util . List < io . katharsis . queryspec . DefaultQuerySpecDeserializer . Parameter > parameters = parseParameters ( parameterMap , resourceInformation ) ; for ( io . katharsis . queryspec . DefaultQuerySpecDeserializer . Parameter parameter : parameters ) { io . katharsis . queryspec . QuerySpec querySpec = rootQuerySpec . getQuerySpec ( parameter . resourceInformation ) ; if ( querySpec == null ) { querySpec = rootQuerySpec . getOrCreateQuerySpec ( parameter . resourceInformation ) ; setupDefaults ( querySpec ) ; } switch ( parameter . paramType ) { case sort : deserializeSort ( querySpec , parameter ) ; break ; case filter : deserializeFilter ( querySpec , parameter ) ; break ; case include : deserializeIncludes ( querySpec , parameter ) ; break ; case fields : deserializeFields ( querySpec , parameter ) ; break ; case page : deserializePage ( querySpec , parameter ) ; break ; default : throw new java . lang . IllegalStateException ( parameter . paramType . toString ( ) ) ; } } return rootQuerySpec ; }", "test_method": "testFilterGreater ( ) { io . katharsis . queryspec . QuerySpec expectedSpec = new io . katharsis . queryspec . QuerySpec ( io . katharsis . resource . mock . models . Task . class ) ; expectedSpec . addFilter ( new io . katharsis . queryspec . FilterSpec ( java . util . Arrays . asList ( \"id\" ) , io . katharsis . queryspec . FilterOperator . LE , 1L ) ) ; java . util . Map < java . lang . String , java . util . Set < java . lang . String > > params = new java . util . HashMap ( ) ; add ( params , \"filter[tasks][id][LE]\" , \"1\" ) ; io . katharsis . queryspec . QuerySpec actualSpec = deserializer . deserialize ( taskInformation , params ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( expectedSpec , actualSpec )", "method_name": "deserialize", "test_name": "testFilterGreater"}
{"focal_method": "toString ( ) { return ( ( ( ( ( ( ( \"[\" + ( grammar . name ) ) + \".\" ) + ( name ) ) + \",index=\" ) + ( index ) ) + \",line=\" ) + ( tree . getToken ( ) . getLine ( ) ) ) + \"]\" ; }", "test_method": "testRepeatsVisit2 ( ) { org . antlr . runtime . tree . TreeWizard wiz = new org . antlr . runtime . tree . TreeWizard ( org . antlr . test . TestTreeWizard . adaptor , org . antlr . test . TestTreeWizard . tokens ) ; org . antlr . runtime . tree . CommonTree t = ( ( org . antlr . runtime . tree . CommonTree ) ( wiz . create ( \"(A<sp>B<sp>(A<sp>C<sp>B)<sp>B<sp>D<sp>D)\" ) ) ) ; final java . util . List < java . lang . Object > elements = new java . util . ArrayList < java . lang . Object > ( ) ; wiz . visit ( t , wiz . getTokenType ( \"A\" ) , new org . antlr . runtime . tree . TreeWizard . Visitor ( ) { @ org . antlr . test . Override public void visit ( java . lang . Object t ) { elements . add ( t ) ; } } ) ; java . lang . String found = elements . toString ( ) ; java . lang . String expecting = \"[A,<sp>A]\" ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( expecting , found )", "method_name": "toString", "test_name": "testRepeatsVisit2"}
{"focal_method": "or ( com . googlecode . javaewah . EWAHCompressedBitmap [ ] ) { if ( ( bitmaps . length ) == 1 ) return bitmaps [ 0 ] ; int largestSize = com . googlecode . javaewah . EWAHCompressedBitmap . calculateInitialSize ( bitmaps ) ; final com . googlecode . javaewah . EWAHCompressedBitmap container = new com . googlecode . javaewah . EWAHCompressedBitmap ( ( ( int ) ( largestSize * 1.5 ) ) ) ; com . googlecode . javaewah . EWAHCompressedBitmap . orWithContainer ( container , bitmaps ) ; return container ; }", "test_method": "shiftbug004 ( ) { com . googlecode . javaewah . EWAHCompressedBitmap bm1 = com . googlecode . javaewah . EWAHCompressedBitmap . bitmapOf ( 10 , 11 , 12 , 13 , 64 ) ; com . googlecode . javaewah . EWAHCompressedBitmap bm2 = bm1 . shift ( 1 ) ; com . googlecode . javaewah . EWAHCompressedBitmap bm3 = bm1 . or ( bm2 ) ; com . googlecode . javaewah . EWAHCompressedBitmap bm4 = com . googlecode . javaewah . EWAHCompressedBitmap . bitmapOf ( 10 , 11 , 12 , 13 , 14 , 64 , 65 ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( bm3 , bm4 )", "method_name": "or", "test_name": "shiftbug004"}
{"focal_method": "binarySearch ( int , int , int ) { -- toIndex ; while ( toIndex >= fromIndex ) { int mid = ( fromIndex + toIndex ) > > > 1 ; int midVal = get ( mid ) ; if ( midVal > value ) toIndex = mid - 1 ; else if ( midVal < value ) fromIndex = mid + 1 ; else return mid ; } return - ( fromIndex + 1 ) ; }", "test_method": "binarySearchTest ( ) { for ( int bits = 8 ; bits < 16 ; ++ bits ) { for ( int n = 0 ; n < ( NUMBER_TESTS ) ; ++ n ) { int l = rng . nextInt ( MAX_ARRAY_LEN ) ; eu . danieldk . dictomaton . CompactIntArray test = new eu . danieldk . dictomaton . CompactIntArray ( l , bits ) ; java . util . List < java . lang . Integer > check = randomList ( rng , bits , l ) ; java . util . Collections . sort ( check ) ; for ( int i = 0 ; i < l ; ++ i ) test . set ( i , check . get ( i ) ) ; java . util . List < java . lang . Integer > needles = randomList ( rng , bits , l ) ; for ( java . lang . Integer needle : needles ) \"<AssertPlaceHolder>\" ; } } }", "assertion": "org . junit . Assert . assertEquals ( java . util . Collections . binarySearch ( check , needle ) , test . binarySearch ( 0 , test . size ( ) , needle ) )", "method_name": "binarySearch", "test_name": "binarySearchTest"}
{"focal_method": "doSomething ( ) { return 1 ; }", "test_method": "mockGenericClassHavingTypeArgumentOfArrayType ( mockit . GenericMockedTypesTest$GenericBase ) { java . lang . String [ ] result = mock . doSomething ( ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( 0 , result . length )", "method_name": "doSomething", "test_name": "mockGenericClassHavingTypeArgumentOfArrayType"}
{"focal_method": "getBytes ( int , byte [ ] , int , int ) { buffer . getBytes ( index , dst , dstIndex , length ) ; }", "test_method": "testByteArrayTransfer ( ) { byte [ ] value = new byte [ ( com . alibaba . dubbo . remoting . buffer . AbstractChannelBufferTest . BLOCK_SIZE ) * 2 ] ; for ( int i = 0 ; i < ( ( ( buffer . capacity ( ) ) - ( com . alibaba . dubbo . remoting . buffer . AbstractChannelBufferTest . BLOCK_SIZE ) ) + 1 ) ; i += com . alibaba . dubbo . remoting . buffer . AbstractChannelBufferTest . BLOCK_SIZE ) { random . nextBytes ( value ) ; buffer . setBytes ( i , value , random . nextInt ( com . alibaba . dubbo . remoting . buffer . AbstractChannelBufferTest . BLOCK_SIZE ) , com . alibaba . dubbo . remoting . buffer . AbstractChannelBufferTest . BLOCK_SIZE ) ; } random . setSeed ( seed ) ; byte [ ] expectedValue = new byte [ ( com . alibaba . dubbo . remoting . buffer . AbstractChannelBufferTest . BLOCK_SIZE ) * 2 ] ; for ( int i = 0 ; i < ( ( ( buffer . capacity ( ) ) - ( com . alibaba . dubbo . remoting . buffer . AbstractChannelBufferTest . BLOCK_SIZE ) ) + 1 ) ; i += com . alibaba . dubbo . remoting . buffer . AbstractChannelBufferTest . BLOCK_SIZE ) { random . nextBytes ( expectedValue ) ; int valueOffset = random . nextInt ( com . alibaba . dubbo . remoting . buffer . AbstractChannelBufferTest . BLOCK_SIZE ) ; buffer . getBytes ( i , value , valueOffset , com . alibaba . dubbo . remoting . buffer . AbstractChannelBufferTest . BLOCK_SIZE ) ; for ( int j = valueOffset ; j < ( valueOffset + ( com . alibaba . dubbo . remoting . buffer . AbstractChannelBufferTest . BLOCK_SIZE ) ) ; j ++ ) { \"<AssertPlaceHolder>\" ; } } }", "assertion": "org . junit . Assert . assertEquals ( expectedValue [ j ] , value [ j ] )", "method_name": "getBytes", "test_name": "testByteArrayTransfer"}
{"focal_method": "splitIgnoreInQuotes ( java . lang . String , char , boolean ) { final java . lang . String trimmedSource ; if ( splitChar != ( org . csstudio . java . string . StringSplitter . TAB ) ) { trimmedSource = source . replace ( org . csstudio . java . string . StringSplitter . TAB , org . csstudio . java . string . StringSplitter . SPACE ) . trim ( ) ; } else { trimmedSource = source ; } final java . lang . String escapedSource = org . csstudio . java . string . StringSplitter . substituteEscapedQuotes ( trimmedSource ) ; java . lang . String fullRegex = splitChar + ( org . csstudio . java . string . StringSplitter . splitRegex ) ; if ( splitChar == ( org . csstudio . java . string . StringSplitter . PIPE ) ) { fullRegex = \"\\\\\" + fullRegex ; } return java . util . regex . Pattern . compile ( fullRegex ) . splitAsStream ( escapedSource ) . filter ( ( item ) -> ! ( item . isEmpty ( ) ) ) . map ( ( item ) -> item . trim ( ) ) . map ( ( item ) -> deleteHeadTailQuotes ? removeQuotes ( item ) : item ) . map ( ( item ) -> revertQuoteSubsitutions ( item ) ) . toArray ( ( size ) -> new java . lang . String [ size ] ) ; }", "test_method": "xtermWithSingleQuotedArgs ( ) { final java . lang . String command = \"xterm<sp>-T<sp>'Console<sp>CS-DI-IOC-05'<sp>-e<sp>'console<sp>CS-DI-IOC-05'\" ; final java . lang . String [ ] result = org . csstudio . java . string . StringSplitter . splitIgnoreInQuotes ( command , '<sp>' , true ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( 5 , result . length )", "method_name": "splitIgnoreInQuotes", "test_name": "xtermWithSingleQuotedArgs"}
{"focal_method": "doStartTag ( ) { com . tacitknowledge . flip . FeatureService service = getFeatureService ( ) ; if ( service == null ) { throw new com . tacitknowledge . flip . exceptions . FlipException ( \"The<sp>FeatureService<sp>has<sp>not<sp>been<sp>instantiated.\" ) ; } return ( service . getFeatureState ( feature ) ) == ( myState ) ? javax . servlet . jsp . tagext . Tag . EVAL_BODY_INCLUDE : javax . servlet . jsp . tagext . Tag . SKIP_BODY ; }", "test_method": "testEmptyListFeatures ( ) { tag . doStartTag ( ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( \"\" , writer . toString ( ) )", "method_name": "doStartTag", "test_name": "testEmptyListFeatures"}
{"focal_method": "paddedValueOfLength ( int ) { return nl . bzk . migratiebrp . voisc . spd . OperationItem . paddedValueOfLength ( \"<sp>\" , length ) ; }", "test_method": "paddedValueLength2 ( ) { \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( \"<sp>\" , nl . bzk . migratiebrp . voisc . spd . OperationItem . paddedValueOfLength ( 2 ) )", "method_name": "paddedValueOfLength", "test_name": "paddedValueLength2"}
{"focal_method": "is ( hudson . model . Job ) { return job . getFullName ( ) . equals ( name ) ; }", "test_method": "toXMLUTF8 ( ) { java . io . ByteArrayOutputStream baos = new java . io . ByteArrayOutputStream ( ) ; hudson . util . XStream2 xs = new hudson . util . XStream2 ( ) ; java . lang . String msg = \"k<sp>chyb\" ; xs . toXMLUTF8 ( new hudson . util . XStream2EncodingTest . Thing ( msg ) , baos ) ; byte [ ] unspecifiedData = baos . toByteArray ( ) ; hudson . util . XStream2EncodingTest . Thing t = ( ( hudson . util . XStream2EncodingTest . Thing ) ( xs . fromXML ( new java . io . ByteArrayInputStream ( unspecifiedData ) ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertThat ( t . field , org . hamcrest . CoreMatchers . is ( msg ) )", "method_name": "is", "test_name": "toXMLUTF8"}
{"focal_method": "getCount ( ) { return this . count ; }", "test_method": "givenMultiThread_whenBlockSync ( ) { java . util . concurrent . ExecutorService service = java . util . concurrent . Executors . newFixedThreadPool ( 3 ) ; com . baeldung . concurrent . synchronize . BaeldungSynchronizedBlocks synchronizedBlocks = new com . baeldung . concurrent . synchronize . BaeldungSynchronizedBlocks ( ) ; java . util . stream . IntStream . range ( 0 , 1000 ) . forEach ( ( count ) -> service . submit ( synchronizedBlocks :: performSynchronisedTask ) ) ; service . awaitTermination ( 500 , TimeUnit . MILLISECONDS ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( 1000 , synchronizedBlocks . getCount ( ) )", "method_name": "getCount", "test_name": "givenMultiThread_whenBlockSync"}
{"focal_method": "getFirstName ( ) { return firstName ; }", "test_method": "testFieldValueOverwritten ( ) { final org . hyalinedto . test . domainclasses . Person dto = org . hyalinedto . api . Hyaline . dtoFromScratch ( john , new org . hyalinedto . api . DTO ( ) { @ org . hyalinedto . test . api . SuppressWarnings ( \"unused\" ) private java . lang . String firstName = \"Ringo\" ; } ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( \"Ringo\" , dto . getFirstName ( ) )", "method_name": "getFirstName", "test_name": "testFieldValueOverwritten"}
{"focal_method": "get ( org . spf4j . base . Tag ) { java . lang . Object res = baggage . get ( key ) ; if ( res == null ) { if ( ( source ) != null ) { return source . get ( key ) ; } else { return null ; } } else { return ( ( T ) ( res ) ) ; } }", "test_method": "testConverterAvroArray ( ) { org . spf4j . jmx . JMXBeanMapping mxBeanMapping2 = conv . get ( org . spf4j . tsdb2 . avro . TableDef [ ] . class ) ; \"<AssertPlaceHolder>\" ; org . spf4j . tsdb2 . avro . TableDef [ ] defs = new org . spf4j . tsdb2 . avro . TableDef [ ] { org . spf4j . tsdb2 . avro . TableDef . newBuilder ( ) . setId ( 4 ) . setDescription ( \"bla\" ) . setName ( \"name\" ) . setSampleTime ( 10 ) . setColumns ( java . util . Collections . singletonList ( org . spf4j . tsdb2 . avro . ColumnDef . newBuilder ( ) . setName ( \"bla\" ) . setType ( Type . LONG ) . setDescription ( \"bla\" ) . setUnitOfMeasurement ( \"um\" ) . build ( ) ) ) . build ( ) } ; java . lang . Object toOpenValue = mxBeanMapping2 . toOpenValue ( defs ) ; org . spf4j . jmx . OpenTypeConverterTest . LOG . debug ( \"Open<sp>value<sp>{}<sp>from<sp>{}\" , toOpenValue , defs ) ; }", "assertion": "org . junit . Assert . assertNotNull ( mxBeanMapping2 )", "method_name": "get", "test_name": "testConverterAvroArray"}
{"focal_method": "is ( T ) { return new com . github . drrb . rust . netbeans . util . Option < > ( value ) ; }", "test_method": "shouldOnlyReturnMessagesFromTargetFile ( ) { java . io . File mainFile = tempFolder . newFile ( \"main.rs\" ) ; java . io . File modFile = tempFolder . newFile ( \"other.rs\" ) ; java . nio . file . Files . write ( modFile . toPath ( ) , \"pub<sp>fn<sp>other_function()<sp>{<sp>x<sp>x<sp>}\" . getBytes ( com . github . drrb . rust . netbeans . rustbridge . UTF_8 ) ) ; java . util . List < com . github . drrb . rust . netbeans . rustbridge . RustParseMessage > messages = new com . github . drrb . rust . netbeans . rustbridge . RustCompiler ( ) . compile ( mainFile , \"mod<sp>other;\\nfn<sp>main()<sp>{<sp>other::other_function()<sp>}\" , mainFile , com . github . drrb . rust . netbeans . configuration . RustConfiguration . get ( ) . getLibrariesPaths ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertThat ( messages , is ( empty ( ) ) )", "method_name": "is", "test_name": "shouldOnlyReturnMessagesFromTargetFile"}
{"focal_method": "getFullName ( ) { return fullName ; }", "test_method": "testFullName ( ) { org . eclipse . orion . server . core . metastore . WorkspaceInfo workspaceInfo = new org . eclipse . orion . server . core . metastore . WorkspaceInfo ( ) ; java . lang . String fullName = \"Test<sp>Workspace\" ; workspaceInfo . setFullName ( fullName ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( fullName , workspaceInfo . getFullName ( ) )", "method_name": "getFullName", "test_name": "testFullName"}
{"focal_method": "getListeners ( ) { return org . geoserver . platform . GeoServerExtensions . extensions ( org . geoserver . backuprestore . listener . BackupRestoreJobExecutionListener . class ) ; }", "test_method": "testCatalogNotifierIntialization ( ) { org . geoserver . notification . common . NotificationConfiguration cfg = null ; int counter = 0 ; for ( org . geoserver . catalog . event . CatalogListener listener : getGeoServer ( ) . getCatalog ( ) . getListeners ( ) ) { if ( listener instanceof org . geoserver . notification . INotificationCatalogListener ) { counter ++ ; } } \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( 1 , counter )", "method_name": "getListeners", "test_name": "testCatalogNotifierIntialization"}
{"focal_method": "removeForwardingRulesFromLoadBalancer ( java . lang . String , java . util . List ) { validateLoadBalancerId ( loadBalancerId ) ; if ( ( null == forwardingRules ) || ( forwardingRules . isEmpty ( ) ) ) { throw new java . lang . IllegalArgumentException ( \"Missing<sp>required<sp>parameters<sp>[forwardingRules].\" ) ; } java . lang . Object [ ] params = new java . lang . Object [ ] { loadBalancerId } ; java . util . Map < java . lang . String , java . util . List < com . myjeeva . digitalocean . pojo . ForwardingRules > > data = new java . util . HashMap ( ) ; data . put ( \"forwarding_rules\" , forwardingRules ) ; return ( ( com . myjeeva . digitalocean . pojo . Delete ) ( perform ( new com . myjeeva . digitalocean . impl . ApiRequest ( com . myjeeva . digitalocean . common . ApiAction . REMOVE_FORWARDING_RULES_FROM_LOAD_BALANCER , data , params ) ) . getData ( ) ) ) ; }", "test_method": "testRemoveForwardingRulesFromLoadBalancer ( ) { com . myjeeva . digitalocean . pojo . ForwardingRules rule = new com . myjeeva . digitalocean . pojo . ForwardingRules ( ) ; rule . setEntryProtocol ( Protocol . HTTP ) ; rule . setTargetProtocol ( Protocol . HTTP ) ; rule . setEntryPort ( 8080 ) ; rule . setTargetPort ( 8080 ) ; com . myjeeva . digitalocean . pojo . Response result = apiClient . removeForwardingRulesFromLoadBalancer ( loadBalancerIdForInfo , java . util . Arrays . asList ( rule ) ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertNotNull ( result )", "method_name": "removeForwardingRulesFromLoadBalancer", "test_name": "testRemoveForwardingRulesFromLoadBalancer"}
{"focal_method": "getCause ( ) { if ( ( cause ) == null ) { if ( ( causeProxy ) != null ) { cause = causeProxy . createException ( ) ; } } return cause ; }", "test_method": "shouldThrowExceptionWhenUsedClassScopeInjectionOnArquillianResource ( ) { org . mockito . Mockito . when ( resourceProvider . lookup ( ( ( org . jboss . arquillian . test . api . ArquillianResource ) ( org . mockito . Mockito . any ( ) ) ) , org . mockito . Mockito . argThat ( new org . jboss . arquillian . test . impl . enricher . resource . ArquillianResourceTestEnricherTestCase . ClassInjectionAnnotationMatcher ( ) ) ) ) . thenReturn ( resource ) ; org . jboss . arquillian . test . spi . TestEnricher enricher = new org . jboss . arquillian . test . impl . enricher . resource . ArquillianResourceTestEnricher ( ) ; injector . get ( ) . inject ( enricher ) ; org . jboss . arquillian . test . impl . enricher . resource . ArquillianResourceTestEnricherTestCase . ObjectClass3 test = new org . jboss . arquillian . test . impl . enricher . resource . ArquillianResourceTestEnricherTestCase . ObjectClass3 ( ) ; java . lang . Throwable cause = null ; try { enricher . enrich ( test ) ; } catch ( java . lang . RuntimeException ex ) { cause = ex . getCause ( ) ; } \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( org . jboss . arquillian . test . impl . enricher . resource . IllegalStateException . class , cause . getClass ( ) )", "method_name": "getCause", "test_name": "shouldThrowExceptionWhenUsedClassScopeInjectionOnArquillianResource"}
{"focal_method": "deviceId ( ) { return deviceId ; }", "test_method": "testSetDeviceId ( ) { deviceInformation . setDeviceId ( org . onlab . packet . Ip4Address . valueOf ( \"1.1.1.1\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertThat ( deviceInformation . deviceId ( ) , org . hamcrest . CoreMatchers . is ( org . onlab . packet . Ip4Address . valueOf ( \"1.1.1.1\" ) ) )", "method_name": "deviceId", "test_name": "testSetDeviceId"}
{"focal_method": "size ( ) { return ( ( ( historicProcessInstanceIds . size ( ) ) + ( historicDecisionInstanceIds . size ( ) ) ) + ( historicCaseInstanceIds . size ( ) ) ) + ( historicBatchIds . size ( ) ) ; }", "test_method": "testQueryByType ( ) { helper . createMigrationBatchWithSize ( 1 ) ; helper . createMigrationBatchWithSize ( 1 ) ; java . util . List < org . camunda . bpm . engine . batch . BatchStatistics > statistics = managementService . createBatchStatisticsQuery ( ) . type ( Batch . TYPE_PROCESS_INSTANCE_MIGRATION ) . list ( ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( 2 , statistics . size ( ) )", "method_name": "size", "test_name": "testQueryByType"}
{"focal_method": "get ( java . lang . String ) { return com . liferay . journal . content . search . web . configuration . JournalContentSearchWebConfigurationUtil . _configuration . get ( key ) ; }", "test_method": "testMergeFieldsAfterNewFieldValueIsInsertedInTheMiddleOfSeries ( ) { com . liferay . dynamic . data . mapping . model . DDMForm ddmForm = createDDMForm ( ) ; addDDMFormFields ( ddmForm , createTextDDMFormField ( \"Content\" , \"\" , true , true , false ) ) ; com . liferay . dynamic . data . mapping . model . DDMStructure ddmStructure = createStructure ( \"Test<sp>Structure\" , ddmForm ) ; com . liferay . dynamic . data . mapping . storage . Field existingContentField = createField ( ddmStructure . getStructureId ( ) , \"Content\" , createValuesList ( \"Content<sp>1\" , \"Content<sp>3\" ) , createValuesList ( \"Conteudo<sp>1\" , \"Conteudo<sp>3\" ) ) ; com . liferay . dynamic . data . mapping . storage . Field existingFieldsDisplayField = createFieldsDisplayField ( ddmStructure . getStructureId ( ) , \"Content<sp>1\" 0 ) ; com . liferay . dynamic . data . mapping . storage . Fields existingFields = createFields ( existingContentField , existingFieldsDisplayField ) ; com . liferay . dynamic . data . mapping . storage . Field newContentField = createField ( ddmStructure . getStructureId ( ) , \"Content\" , createValuesList ( \"Content<sp>1\" , \"Content<sp>2\" , \"Content<sp>3\" ) , null ) ; com . liferay . dynamic . data . mapping . storage . Field newFieldsDisplayField = createFieldsDisplayField ( ddmStructure . getStructureId ( ) , ( \"Content_INSTANCE_ovho,Content_INSTANCE_zuvh,\" + \"Content_INSTANCE_yiek\" ) ) ; com . liferay . dynamic . data . mapping . storage . Fields newFields = createFields ( newContentField , newFieldsDisplayField ) ; com . liferay . dynamic . data . mapping . storage . Fields actualFields = _ddm . mergeFields ( newFields , existingFields ) ; com . liferay . dynamic . data . mapping . storage . Field actualContentField = actualFields . get ( \"Content\" ) ; \"<AssertPlaceHolder>\" ; testValues ( actualContentField . getValues ( LocaleUtil . US ) , \"Content<sp>1\" , \"Content<sp>2\" , \"Content<sp>3\" ) ; testValues ( actualContentField . getValues ( LocaleUtil . BRAZIL ) , \"Conteudo<sp>1\" , \"Content<sp>2\" , \"Conteudo<sp>3\" ) ; }", "assertion": "org . junit . Assert . assertNotNull ( actualContentField )", "method_name": "get", "test_name": "testMergeFieldsAfterNewFieldValueIsInsertedInTheMiddleOfSeries"}
{"focal_method": "isValid ( ) { return satisfiesConstraints ( constraints ) ; }", "test_method": "testInvalidImageTypeShowsAsInvalid ( ) { co . cask . coopr . layout . NodeLayout badNodeLayout = new co . cask . coopr . layout . NodeLayout ( \"large-mem\" , \"rhel5\" , com . google . common . collect . ImmutableSet . of ( \"namenode\" ) ) ; com . google . common . collect . Multiset < co . cask . coopr . layout . NodeLayout > counts = com . google . common . collect . HashMultiset . create ( ) ; counts . add ( badNodeLayout , 1 ) ; co . cask . coopr . layout . ClusterLayout layout = new co . cask . coopr . layout . ClusterLayout ( co . cask . coopr . layout . ClusterLayoutTest . constraints , counts ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertFalse ( layout . isValid ( ) )", "method_name": "isValid", "test_name": "testInvalidImageTypeShowsAsInvalid"}
{"focal_method": "size ( ) { try { return ins . available ( ) ; } catch ( java . io . IOException e ) { throw org . nutz . lang . Lang . wrapThrow ( e ) ; } }", "test_method": "test_param_names ( ) { org . nutz . dao . impl . sql . NutSql sql = org . nutz . dao . impl . sql . SqlLiteralTest . L ( \"UPDATE<sp>dao_platoon<sp>SET<sp>name=@name1,base=@baseName2,leader=@leaderName3<sp>WHERE<sp>id=@id4\" ) ; java . lang . String [ ] paramNames = sql . literal . getParamIndexes ( ) . names ( ) . toArray ( new java . lang . String [ sql . literal . getParamIndexes ( ) . names ( ) . size ( ) ] ) ; java . lang . String [ ] result = new java . lang . String [ ] { \"leaderName3\" , \"id4\" , \"baseName2\" , \"name1\" } ; java . util . Arrays . sort ( paramNames ) ; java . util . Arrays . sort ( result ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertArrayEquals ( paramNames , result )", "method_name": "size", "test_name": "test_param_names"}
{"focal_method": "api ( com . sendgrid . Request ) { com . sendgrid . Request req = new com . sendgrid . Request ( ) ; req . setMethod ( request . getMethod ( ) ) ; req . setBaseUri ( this . host ) ; req . setEndpoint ( ( ( ( \"/\" + ( version ) ) + \"/\" ) + ( request . getEndpoint ( ) ) ) ) ; req . setBody ( request . getBody ( ) ) ; for ( Map . Entry < java . lang . String , java . lang . String > header : this . requestHeaders . entrySet ( ) ) { req . addHeader ( header . getKey ( ) , header . getValue ( ) ) ; } for ( Map . Entry < java . lang . String , java . lang . String > queryParam : request . getQueryParams ( ) . entrySet ( ) ) { req . addQueryParam ( queryParam . getKey ( ) , queryParam . getValue ( ) ) ; } return makeCall ( req ) ; }", "test_method": "test_senders_get ( ) { com . sendgrid . SendGrid sg = new com . sendgrid . SendGrid ( \"SENDGRID_API_KEY\" , true ) ; sg . setHost ( \"localhost:4010\" ) ; sg . addRequestHeader ( \"X-Mock\" , \"200\" ) ; com . sendgrid . Request request = new com . sendgrid . Request ( ) ; request . setMethod ( Method . GET ) ; request . setEndpoint ( \"senders\" ) ; com . sendgrid . Response response = sg . api ( request ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( 200 , response . getStatusCode ( ) )", "method_name": "api", "test_name": "test_senders_get"}
{"focal_method": "equalTo ( java . util . List ) { return org . codice . ddf . catalog . ui . forms . builder . XmlModelBuilder . FACTORY . createPropertyIsEqualTo ( org . codice . ddf . catalog . ui . forms . builder . XmlModelBuilder . Mapper . binaryComparisonType ( children ) ) ; }", "test_method": "testGetChecksumForWithSoftlink ( ) { final java . nio . file . Path absoluteFilePath = ddfHome . resolve ( createFile ( \"test.txt\" ) ) . toAbsolutePath ( ) ; final java . nio . file . Path path2 = ddfHome . resolve ( createSoftLink ( absoluteFilePath . getParent ( ) , \"test2.txt\" , absoluteFilePath ) ) . toAbsolutePath ( ) ; final java . lang . String checksum = pathUtils . getChecksumFor ( absoluteFilePath ) ; final java . lang . String checksum2 = pathUtils . getChecksumFor ( path2 ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertThat ( checksum2 , org . hamcrest . Matchers . equalTo ( checksum ) )", "method_name": "equalTo", "test_name": "testGetChecksumForWithSoftlink"}
{"focal_method": "toStringUnsorted ( com . splicemachine . homeless . ResultSet ) { return com . splicemachine . homeless . TestUtils . FormattedResult . ResultFactory . convert ( \"\" , rs , false ) . toString ( ) . trim ( ) ; }", "test_method": "testMinusDateColumn ( ) { java . lang . String sqlText = java . lang . String . format ( \"select<sp>d<sp>+<sp>1<sp>from<sp>%s\" , com . splicemachine . derby . impl . sql . execute . operations . SimpleDateArithmeticIT . QUALIFIED_TABLE_NAME ) ; java . sql . ResultSet rs = com . splicemachine . derby . impl . sql . execute . operations . SimpleDateArithmeticIT . spliceClassWatcher . executeQuery ( sqlText ) ; java . lang . String expected = \"1<sp>|\\n\" + ( \"------------\\n\" + \"1988-12-27<sp>|\" ) ; \"<AssertPlaceHolder>\" ; rs . close ( ) ; }", "assertion": "org . junit . Assert . assertEquals ( ( ( \"\\n\" + sqlText ) + \"\\n\" ) , expected , TestUtils . FormattedResult . ResultFactory . toStringUnsorted ( rs ) )", "method_name": "toStringUnsorted", "test_name": "testMinusDateColumn"}
{"focal_method": "deductFromBalanceBy ( java . math . BigDecimal ) { if ( ( amountToDeduct . compareTo ( balance ) ) > 0 ) { throw new java . lang . UnsupportedOperationException ( \"Insufficient<sp>funds.\" ) ; } balance = subtractFromBalance ( amountToDeduct ) ; }", "test_method": "itShouldDeductFromCustomerAccountBalance ( ) { customer . deductFromBalanceBy ( new java . math . BigDecimal ( 200 ) ) ; srp . example2 . fixed . Account expectedAccount = new srp . example2 . fixed . Account ( new java . math . BigDecimal ( 300 ) , accountHolders ) ; srp . example2 . fixed . Customer expectedCustomer = new srp . example2 . fixed . Customer ( \"srp.example2.Customer<sp>name\" , expectedAccount ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( expectedCustomer , customer )", "method_name": "deductFromBalanceBy", "test_name": "itShouldDeductFromCustomerAccountBalance"}
{"focal_method": "fireAllRules ( ) { return 0 ; }", "test_method": "testJoinLongToDouble ( ) { final java . lang . String drl1 = ( ( ( ( ( ( ( ( ( \"import<sp>\" + ( org . drools . modelcompiler . TypeCoercionTest . DoubleHolder . class . getCanonicalName ( ) ) ) + \";\\n\" ) + \"import<sp>\" ) + ( org . drools . modelcompiler . TypeCoercionTest . LongHolder . class . getCanonicalName ( ) ) ) + \";\\n\" ) + \"rule<sp>R<sp>when\\n\" ) + \"<sp>LongHolder(<sp>$l<sp>:<sp>value<sp>)\\n\" ) + \"<sp>DoubleHolder(<sp>value<sp>>=<sp>$l<sp>)\\n\" ) + \"then\\n\" ) + \"end\\n\" ; org . kie . api . runtime . KieSession ksession = getKieSession ( drl1 ) ; ksession . insert ( new org . drools . modelcompiler . TypeCoercionTest . LongHolder ( ) ) ; ksession . insert ( new org . drools . modelcompiler . TypeCoercionTest . DoubleHolder ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( 1 , ksession . fireAllRules ( ) )", "method_name": "fireAllRules", "test_name": "testJoinLongToDouble"}
{"focal_method": "maakIngeschrevene ( ) { return nl . bzk . brp . domain . leveringmodel . MetaObject . maakBuilder ( ) . metObjectElement ( nl . bzk . brp . domain . element . ElementHelper . getObjectElement ( Element . PERSOON . getId ( ) ) ) . metId ( nl . bzk . brp . levering . lo3 . support . MetaObjectUtil . idTeller . getAndIncrement ( ) ) . metGroep ( ) . metGroepElement ( nl . bzk . brp . domain . element . ElementHelper . getGroepElement ( Element . PERSOON_IDENTITEIT . getId ( ) ) ) . metRecord ( ) . metId ( nl . bzk . brp . levering . lo3 . support . MetaObjectUtil . idTeller . getAndIncrement ( ) ) . metAttribuut ( nl . bzk . brp . domain . element . ElementHelper . getAttribuutElement ( Element . PERSOON_SOORTCODE . getId ( ) ) , \"I\" ) . eindeRecord ( ) . eindeGroep ( ) . eindeObject ( ) ; }", "test_method": "testLeeg ( ) { final nl . bzk . migratiebrp . conversie . model . brp . BrpStapel < nl . bzk . migratiebrp . conversie . model . brp . groep . BrpDeelnameEuVerkiezingenInhoud > brpEUVerkiezingen = doMapping ( mapper , nl . bzk . brp . levering . lo3 . support . MetaObjectUtil . maakIngeschrevene ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertNull ( brpEUVerkiezingen )", "method_name": "maakIngeschrevene", "test_name": "testLeeg"}
{"focal_method": "fromJson ( com . fasterxml . jackson . databind . JsonNode ) { if ( node instanceof com . fasterxml . jackson . databind . node . ObjectNode ) { com . fasterxml . jackson . databind . node . ObjectNode onode = ( ( com . fasterxml . jackson . databind . node . ObjectNode ) ( node ) ) ; java . lang . String firstField = onode . fieldNames ( ) . next ( ) ; if ( ( com . redhat . lightblue . query . UnaryLogicalOperator . fromString ( firstField ) ) != null ) { return com . redhat . lightblue . query . UnaryLogicalExpression . fromJson ( onode ) ; } else if ( ( com . redhat . lightblue . query . NaryLogicalOperator . fromString ( firstField ) ) != null ) { return com . redhat . lightblue . query . NaryLogicalExpression . fromJson ( onode ) ; } else { return com . redhat . lightblue . query . ComparisonExpression . fromJson ( onode ) ; } } else { throw com . redhat . lightblue . util . Error . get ( QueryConstants . ERR_INVALID_QUERY , node . toString ( ) ) ; } }", "test_method": "testFromJson ( ) { com . fasterxml . jackson . databind . JsonNode jsonNode = com . fasterxml . jackson . databind . node . JsonNodeFactory . withExactBigDecimals ( false ) . binaryNode ( new byte [ 0 ] ) ; java . lang . Object fromJson = binaryType . fromJson ( jsonNode ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertTrue ( ( fromJson instanceof byte [ ] ) )", "method_name": "fromJson", "test_name": "testFromJson"}
{"focal_method": "get ( org . apache . kafka . connect . data . Field ) { java . lang . Object val = values [ field . index ( ) ] ; if ( ( val == null ) && ( ( field . schema ( ) . defaultValue ( ) ) != null ) ) { val = field . schema ( ) . defaultValue ( ) ; } return val ; }", "test_method": "testGetGlobalConsumerConfigsWithGlobalConsumerOverridenPrefix ( ) { props . put ( org . apache . kafka . streams . StreamsConfig . consumerPrefix ( ConsumerConfig . MAX_POLL_RECORDS_CONFIG ) , \"5\" ) ; props . put ( org . apache . kafka . streams . StreamsConfig . globalConsumerPrefix ( ConsumerConfig . MAX_POLL_RECORDS_CONFIG ) , \"50\" ) ; final java . util . Map < java . lang . String , java . lang . Object > returnedProps = streamsConfig . getGlobalConsumerConfigs ( \"clientId\" ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( \"50\" , returnedProps . get ( ConsumerConfig . MAX_POLL_RECORDS_CONFIG ) )", "method_name": "get", "test_name": "testGetGlobalConsumerConfigsWithGlobalConsumerOverridenPrefix"}
{"focal_method": "getCount ( ) { this . ensureInit ( ) ; return count ; }", "test_method": "testHelloWorldContinuations ( ) { javax . xml . namespace . QName serviceName = new javax . xml . namespace . QName ( \"http://cxf.apache.org/systest/jaxws\" , \"http://cxf.apache.org/systest/jaxws\" 1 ) ; java . net . URL wsdlURL = getClass ( ) . getClassLoader ( ) . getResource ( org . apache . cxf . systest . jms . continuations . HelloWorldContinuationsClientServerTest . WSDL_PATH ) ; org . apache . cxf . systest . jms . continuations . HelloContinuationService service = new org . apache . cxf . systest . jms . continuations . HelloContinuationService ( wsdlURL , serviceName ) ; final org . apache . cxf . systest . jms . continuations . HelloContinuation helloPort = markForClose ( service . getPort ( org . apache . cxf . systest . jms . continuations . HelloContinuation . class , cff ) ) ; java . util . concurrent . ExecutorService executor = java . util . concurrent . Executors . newCachedThreadPool ( ) ; java . util . concurrent . CountDownLatch startSignal = new java . util . concurrent . CountDownLatch ( 1 ) ; java . util . concurrent . CountDownLatch helloDoneSignal = new java . util . concurrent . CountDownLatch ( 5 ) ; executor . execute ( new org . apache . cxf . systest . jms . continuations . HelloWorker ( helloPort , \"Fred\" , \"\" , startSignal , helloDoneSignal ) ) ; executor . execute ( new org . apache . cxf . systest . jms . continuations . HelloWorker ( helloPort , \"Barry\" , \"Jameson\" , startSignal , helloDoneSignal ) ) ; executor . execute ( new org . apache . cxf . systest . jms . continuations . HelloWorker ( helloPort , \"Harry\" , \"\" , startSignal , helloDoneSignal ) ) ; executor . execute ( new org . apache . cxf . systest . jms . continuations . HelloWorker ( helloPort , \"Rob\" , \"Davidson\" , startSignal , helloDoneSignal ) ) ; executor . execute ( new org . apache . cxf . systest . jms . continuations . HelloWorker ( helloPort , \"James\" , \"ServiceMix\" , startSignal , helloDoneSignal ) ) ; startSignal . countDown ( ) ; helloDoneSignal . await ( 60 , TimeUnit . SECONDS ) ; executor . shutdownNow ( ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( \"http://cxf.apache.org/systest/jaxws\" 0 , 0 , helloDoneSignal . getCount ( ) )", "method_name": "getCount", "test_name": "testHelloWorldContinuations"}
{"focal_method": "add ( E ) { ea [ last ] = event ; if ( ( ++ ( last ) ) == ( maxSize ) ) last = 0 ; if ( ( numElems ) < ( maxSize ) ) ( numElems ) ++ ; else if ( ( ++ ( first ) ) == ( maxSize ) ) first = 0 ; }", "test_method": "testSimpleP2 ( ) { java . util . List < ch . qos . logback . core . pattern . parser . Token > tl = new ch . qos . logback . core . pattern . parser . TokenStream ( \"X<sp>%a<sp>%-12.550(hello<sp>%class{.4?})\" ) . tokenize ( ) ; java . util . List < ch . qos . logback . core . pattern . parser . Token > witness = new java . util . ArrayList < ch . qos . logback . core . pattern . parser . Token > ( ) ; witness . add ( new ch . qos . logback . core . pattern . parser . Token ( Token . LITERAL , \"X<sp>\" ) ) ; witness . add ( Token . PERCENT_TOKEN ) ; witness . add ( new ch . qos . logback . core . pattern . parser . Token ( Token . SIMPLE_KEYWORD , \"a\" ) ) ; witness . add ( new ch . qos . logback . core . pattern . parser . Token ( Token . LITERAL , \"<sp>\" ) ) ; witness . add ( Token . PERCENT_TOKEN ) ; witness . add ( new ch . qos . logback . core . pattern . parser . Token ( Token . FORMAT_MODIFIER , \"-12.550\" ) ) ; witness . add ( Token . BARE_COMPOSITE_KEYWORD_TOKEN ) ; witness . add ( new ch . qos . logback . core . pattern . parser . Token ( Token . LITERAL , \"hello<sp>\" ) ) ; witness . add ( Token . PERCENT_TOKEN ) ; witness . add ( new ch . qos . logback . core . pattern . parser . Token ( Token . SIMPLE_KEYWORD , \"class\" ) ) ; java . util . List < java . lang . String > ol = new java . util . ArrayList < java . lang . String > ( ) ; ol . add ( \".4?\" ) ; witness . add ( new ch . qos . logback . core . pattern . parser . Token ( Token . OPTION , ol ) ) ; witness . add ( Token . RIGHT_PARENTHESIS_TOKEN ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( witness , tl )", "method_name": "add", "test_name": "testSimpleP2"}
{"focal_method": "isPrivate ( java . lang . String ) { return ( methodSignature != null ) && ( methodSignature . matches ( ( ( ( org . junithelper . core . util . AccessModifierDetector . RegExp . Prefix ) + \"private\" ) + ( org . junithelper . core . util . AccessModifierDetector . RegExp . Suffix ) ) ) ) ; }", "test_method": "isPrivate_A$String_StringIsNull ( ) { java . lang . String methodSignature = null ; boolean actual = org . junithelper . core . util . AccessModifierDetector . isPrivate ( methodSignature ) ; boolean expected = false ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertThat ( actual , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( expected ) ) )", "method_name": "isPrivate", "test_name": "isPrivate_A$String_StringIsNull"}
{"focal_method": "hasNext ( ) { return this . iterator . hasNext ( ) ; }", "test_method": "keyIteratorIsEmpty ( ) { java . util . Iterator < java . lang . String > kit = this . dataset . keyIterator ( ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertFalse ( kit . hasNext ( ) )", "method_name": "hasNext", "test_name": "keyIteratorIsEmpty"}
{"focal_method": "asElement ( ) { return new nl . moderniseringgba . migratie . conversie . model . lo3 . element . Lo3AangifteAdreshouding ( code ) ; }", "test_method": "tesGroepen10 ( ) { final java . lang . String message = maakLo3VerblijfplaatsInhoud ( new nl . moderniseringgba . migratie . conversie . model . lo3 . element . Lo3GemeenteCode ( \"1234\" ) , new nl . moderniseringgba . migratie . conversie . model . lo3 . element . Lo3Datum ( 20120101 ) , Lo3FunctieAdresEnum . BRIEFADRES . asElement ( ) , null , new nl . moderniseringgba . migratie . conversie . model . lo3 . element . Lo3Datum ( 20120101 ) , \"straatnaam\" , \"openbareRuimte\" , new nl . moderniseringgba . migratie . conversie . model . lo3 . element . Lo3Huisnummer ( 101 ) , 'A' , \"toev\" , null , \"1234AB\" , \"woonplaatsnaam\" , \"idVerblijfplaats\" , \"idNummer\" , null , null , null , null , null , null , null , null , Lo3AangifteAdreshoudingEnum . AMBSTHALVE . asElement ( ) , null ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( \"\" , message )", "method_name": "asElement", "test_name": "tesGroepen10"}
{"focal_method": "prepareStatement ( java . lang . String ) { com . salesforce . phoenix . jdbc . PhoenixPreparedStatement statement = new com . salesforce . phoenix . jdbc . PhoenixPreparedStatement ( this , sql ) ; statements . add ( statement ) ; return statement ; }", "test_method": "testAddKVColumnToNewFamily ( ) { long ts = nextTimestamp ( ) ; java . lang . String tenantId = getOrganizationId ( ) ; initATableValues ( tenantId , getDefaultSplits ( tenantId ) , null , ts ) ; java . util . Properties props = new java . util . Properties ( ) ; props . setProperty ( PhoenixRuntime . CURRENT_SCN_ATTRIB , java . lang . Long . toString ( ( ts + 5 ) ) ) ; java . sql . Connection conn1 = java . sql . DriverManager . getConnection ( com . salesforce . phoenix . end2end . PHOENIX_JDBC_URL , props ) ; conn1 . createStatement ( ) . executeUpdate ( ( ( \"ALTER<sp>TABLE<sp>\" + ( ATABLE_NAME ) ) + \"<sp>ADD<sp>newcf.z_integer<sp>integer\" ) ) ; conn1 . close ( ) ; props . setProperty ( PhoenixRuntime . CURRENT_SCN_ATTRIB , java . lang . Long . toString ( ( ts + 6 ) ) ) ; java . sql . Connection conn2 = java . sql . DriverManager . getConnection ( com . salesforce . phoenix . end2end . PHOENIX_JDBC_URL , props ) ; java . lang . String query = \"SELECT<sp>z_integer<sp>FROM<sp>aTable\" ; \"<AssertPlaceHolder>\" ; conn2 . close ( ) ; props . setProperty ( PhoenixRuntime . CURRENT_SCN_ATTRIB , java . lang . Long . toString ( ( ts + 3 ) ) ) ; java . sql . Connection conn3 = java . sql . DriverManager . getConnection ( com . salesforce . phoenix . end2end . PHOENIX_JDBC_URL , props ) ; try { conn3 . prepareStatement ( query ) . executeQuery ( ) . next ( ) ; org . junit . Assert . fail ( ) ; } catch ( com . salesforce . phoenix . schema . ColumnNotFoundException e ) { } }", "assertion": "org . junit . Assert . assertTrue ( conn2 . prepareStatement ( query ) . executeQuery ( ) . next ( ) )", "method_name": "prepareStatement", "test_name": "testAddKVColumnToNewFamily"}
{"focal_method": "isGreaterOrEqual ( ) { return ( ( this ) == ( org . eclipse . n4js . semver . SemverMatcher . VersionNumberRelation . Equal ) ) || ( ( this ) == ( org . eclipse . n4js . semver . SemverMatcher . VersionNumberRelation . Greater ) ) ; }", "test_method": "testNodeJsVersion ( ) { final org . eclipse . n4js . utils . process . ProcessResult result = commandFactory . checkBinaryVersionCommand ( nodeJsBinary ) . execute ( ) ; final org . eclipse . n4js . semver . Semver . VersionNumber currentVersion = semverHelper . parseVersionNumber ( result . getStdOut ( ) . trim ( ) ) ; java . lang . String msg = ( ( ( ( \"Version<sp>of<sp>node<sp>in<sp>\" + ( nodeJsBinary . getBinaryAbsolutePath ( ) ) ) + \":<sp>\" ) + currentVersion ) + \",<sp>need<sp>at<sp>least<sp>\" ) + ( org . eclipse . n4js . binaries . BinariesConstants . NODE_MIN_VERSION ) ; org . eclipse . n4js . semver . SemverMatcher . VersionNumberRelation relation = org . eclipse . n4js . semver . SemverMatcher . relation ( currentVersion , BinariesConstants . NODE_MIN_VERSION ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertTrue ( msg , relation . isGreaterOrEqual ( ) )", "method_name": "isGreaterOrEqual", "test_name": "testNodeJsVersion"}
{"focal_method": "execute ( java . util . List ) { java . util . List < java . lang . Long > personIds = new java . util . ArrayList < java . lang . Long > ( ) ; java . util . List < java . lang . Long > groupIds = new java . util . ArrayList < java . lang . Long > ( ) ; java . lang . Long id ; for ( org . eurekastreams . server . domain . dto . DisplayInfoSettable ds : inDisplaySettables ) { id = ds . getEntityId ( ) ; switch ( ds . getEntityType ( ) ) { case PERSON : if ( ! ( personIds . contains ( id ) ) ) { personIds . add ( id ) ; } break ; case GROUP : if ( ! ( groupIds . contains ( id ) ) ) { groupIds . add ( id ) ; } break ; default : break ; } } java . util . List < org . eurekastreams . server . search . modelview . PersonModelView > personDTOs = getPersonModelViewsByIdsMapper . execute ( personIds ) ; java . util . List < org . eurekastreams . server . search . modelview . DomainGroupModelView > groupDTOs = getGroupModelViewsByIdsMapper . execute ( groupIds ) ; java . util . Map < java . lang . String , org . eurekastreams . server . search . modelview . PersonModelView > peopleByAccountIdsMap = new java . util . HashMap < java . lang . String , org . eurekastreams . server . search . modelview . PersonModelView > ( ) ; java . util . Map < java . lang . String , org . eurekastreams . server . search . modelview . DomainGroupModelView > domainGroupsByShortNamesMap = new java . util . HashMap < java . lang . String , org . eurekastreams . server . search . modelview . DomainGroupModelView > ( ) ; for ( org . eurekastreams . server . search . modelview . PersonModelView person : personDTOs ) { peopleByAccountIdsMap . put ( person . getAccountId ( ) , person ) ; } for ( org . eurekastreams . server . search . modelview . DomainGroupModelView domainGroup : groupDTOs ) { domainGroupsByShortNamesMap . put ( domainGroup . getShortName ( ) , domainGroup ) ; } org . eurekastreams . server . search . modelview . PersonModelView pmv ; org . eurekastreams . server . search . modelview . DomainGroupModelView gmv ; for ( org . eurekastreams . server . domain . dto . DisplayInfoSettable ds : inDisplaySettables ) { if ( ( ds . getEntityType ( ) ) == ( org . eurekastreams . server . domain . EntityType . PERSON ) ) { pmv = peopleByAccountIdsMap . get ( ds . getStreamUniqueKey ( ) ) ; if ( pmv != null ) { ds . setAvatarId ( pmv . getAvatarId ( ) ) ; ds . setDisplayName ( pmv . getDisplayName ( ) ) ; } } else if ( ( ds . getEntityType ( ) ) == ( org . eurekastreams . server . domain . EntityType . GROUP ) ) { gmv = domainGroupsByShortNamesMap . get ( ds . getStreamUniqueKey ( ) ) ; if ( gmv != null ) { ds . setAvatarId ( gmv . getAvatarId ( ) ) ; ds . setDisplayName ( gmv . getDisplayName ( ) ) ; } } } return inDisplaySettables ; }", "test_method": "testExecuteGroupNotSubscribed ( ) { sut = new org . eurekastreams . server . persistence . mappers . db . notification . GetStreamActivitySubscriptionDbMapper ( org . eurekastreams . server . domain . EntityType . GROUP ) ; ( ( org . eurekastreams . server . persistence . mappers . BaseDomainMapper ) ( sut ) ) . setEntityManager ( getEntityManager ( ) ) ; org . eurekastreams . server . persistence . mappers . requests . GetStreamActivitySubscriptionMapperRequest request = new org . eurekastreams . server . persistence . mappers . requests . GetStreamActivitySubscriptionMapperRequest ( 99 , 1 ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertFalse ( sut . execute ( request ) )", "method_name": "execute", "test_name": "testExecuteGroupNotSubscribed"}
{"focal_method": "getObject ( ) { return object ; }", "test_method": "createProducerWithDefaultMetadata ( ) { final org . springframework . integration . kafka . support . ProducerMetadata < byte [ ] , byte [ ] > producerMetadata = new org . springframework . integration . kafka . support . ProducerMetadata < byte [ ] , byte [ ] > ( \"test\" ) ; final org . springframework . integration . kafka . support . ProducerMetadata < byte [ ] , byte [ ] > tm = org . mockito . Mockito . spy ( producerMetadata ) ; final org . springframework . integration . kafka . support . ProducerFactoryBean < byte [ ] , byte [ ] > producerFactoryBean = new org . springframework . integration . kafka . support . ProducerFactoryBean < byte [ ] , byte [ ] > ( tm , \"localhost:9092\" ) ; final kafka . javaapi . producer . Producer < byte [ ] , byte [ ] > producer = producerFactoryBean . getObject ( ) ; \"<AssertPlaceHolder>\" ; org . mockito . Mockito . verify ( tm , org . mockito . Mockito . times ( 1 ) ) . getPartitioner ( ) ; org . mockito . Mockito . verify ( tm , org . mockito . Mockito . times ( 1 ) ) . getCompressionCodec ( ) ; org . mockito . Mockito . verify ( tm , org . mockito . Mockito . times ( 1 ) ) . getValueEncoder ( ) ; org . mockito . Mockito . verify ( tm , org . mockito . Mockito . times ( 1 ) ) . getKeyEncoder ( ) ; org . mockito . Mockito . verify ( tm , org . mockito . Mockito . times ( 1 ) ) . isAsync ( ) ; org . mockito . Mockito . verify ( tm , org . mockito . Mockito . times ( 0 ) ) . getBatchNumMessages ( ) ; }", "assertion": "org . junit . Assert . assertTrue ( ( producer != null ) )", "method_name": "getObject", "test_name": "createProducerWithDefaultMetadata"}
{"focal_method": "checkOperationOutputQuantities ( com . qcadoo . mes . states . StateChangeContext ) { com . qcadoo . model . api . Entity techology = stateChangeContext . getOwner ( ) ; com . qcadoo . model . api . Entity technology = techology . getDataDefinition ( ) . get ( techology . getId ( ) ) ; java . util . List < java . lang . String > messages = normService . checkOperationOutputQuantities ( technology ) ; if ( ! ( messages . isEmpty ( ) ) ) { stateChangeContext . addValidationError ( \"technologies.technology.validate.global.error.treeIsNotValid\" ) ; java . lang . StringBuilder builder = new java . lang . StringBuilder ( ) ; for ( java . lang . String message : messages ) { builder . append ( message ) ; builder . append ( \",<sp>\" ) ; } stateChangeContext . addMessage ( \"technologies.technology.validate.error.invalidQuantity\" , StateMessageType . FAILURE , false , builder . toString ( ) ) ; } return messages . isEmpty ( ) ; }", "test_method": "shouldReturnNoErrorsIfTheQuantitiesDoMatch ( ) { com . qcadoo . model . api . EntityTree tree = com . qcadoo . mes . timeNormsForOperations . NormServiceTest . mockEntityTreeIterator ( asList ( operComp1 ) ) ; given ( technology . getTreeField ( \"operationComponents\" ) ) . willReturn ( tree ) ; given ( technologyService . getProductCountForOperationComponent ( operComp1 ) ) . willReturn ( new java . math . BigDecimal ( 13.5 ) ) ; given ( operComp1 . getDecimalField ( \"productionInOneCycle\" ) ) . willReturn ( new java . math . BigDecimal ( 13.5 ) ) ; java . util . List < java . lang . String > messages = normService . checkOperationOutputQuantities ( technology ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( 0 , messages . size ( ) )", "method_name": "checkOperationOutputQuantities", "test_name": "shouldReturnNoErrorsIfTheQuantitiesDoMatch"}
{"focal_method": "toString ( com . hartwig . hmftools . common . purple . region . FittedRegion ) { return new java . util . StringJoiner ( com . hartwig . hmftools . common . purple . region . FittedRegionFile . DELIMITER ) . add ( java . lang . String . valueOf ( copyNumber . chromosome ( ) ) ) . add ( java . lang . String . valueOf ( copyNumber . start ( ) ) ) . add ( java . lang . String . valueOf ( copyNumber . end ( ) ) ) . add ( java . lang . String . valueOf ( copyNumber . status ( ) ) ) . add ( \"\" ) . add ( java . lang . String . valueOf ( copyNumber . bafCount ( ) ) ) . add ( com . hartwig . hmftools . common . purple . region . FittedRegionFile . FORMAT . format ( copyNumber . observedBAF ( ) ) ) . add ( com . hartwig . hmftools . common . purple . region . FittedRegionFile . FORMAT . format ( copyNumber . minorAllelePloidy ( ) ) ) . add ( com . hartwig . hmftools . common . purple . region . FittedRegionFile . FORMAT . format ( copyNumber . minorAllelePloidyDeviation ( ) ) ) . add ( com . hartwig . hmftools . common . purple . region . FittedRegionFile . FORMAT . format ( copyNumber . observedTumorRatio ( ) ) ) . add ( com . hartwig . hmftools . common . purple . region . FittedRegionFile . FORMAT . format ( copyNumber . observedNormalRatio ( ) ) ) . add ( com . hartwig . hmftools . common . purple . region . FittedRegionFile . FORMAT . format ( copyNumber . majorAllelePloidy ( ) ) ) . add ( com . hartwig . hmftools . common . purple . region . FittedRegionFile . FORMAT . format ( copyNumber . majorAllelePloidyDeviation ( ) ) ) . add ( com . hartwig . hmftools . common . purple . region . FittedRegionFile . FORMAT . format ( copyNumber . deviationPenalty ( ) ) ) . add ( com . hartwig . hmftools . common . purple . region . FittedRegionFile . FORMAT . format ( copyNumber . tumorCopyNumber ( ) ) ) . add ( com . hartwig . hmftools . common . purple . region . FittedRegionFile . FORMAT . format ( copyNumber . fittedTumorCopyNumber ( ) ) ) . add ( com . hartwig . hmftools . common . purple . region . FittedRegionFile . FORMAT . format ( copyNumber . fittedBAF ( ) ) ) . add ( com . hartwig . hmftools . common . purple . region . FittedRegionFile . FORMAT . format ( copyNumber . refNormalisedCopyNumber ( ) ) ) . add ( java . lang . String . valueOf ( copyNumber . ratioSupport ( ) ) ) . add ( java . lang . String . valueOf ( copyNumber . support ( ) ) ) . add ( java . lang . String . valueOf ( copyNumber . depthWindowCount ( ) ) ) . add ( com . hartwig . hmftools . common . purple . region . FittedRegionFile . FORMAT . format ( copyNumber . tumorBAF ( ) ) ) . add ( com . hartwig . hmftools . common . purple . region . FittedRegionFile . FORMAT . format ( copyNumber . gcContent ( ) ) ) . add ( java . lang . String . valueOf ( copyNumber . svCluster ( ) ) ) . add ( com . hartwig . hmftools . common . purple . region . FittedRegionFile . FORMAT . format ( copyNumber . eventPenalty ( ) ) ) . add ( java . lang . String . valueOf ( copyNumber . minStart ( ) ) ) . add ( java . lang . String . valueOf ( copyNumber . maxStart ( ) ) ) . toString ( ) ; }", "test_method": "testToFromString ( ) { final com . hartwig . hmftools . common . purple . region . FittedRegion expected = com . hartwig . hmftools . common . purple . region . FittedRegionFileTest . createRandom ( new java . util . Random ( ) ) ; final com . hartwig . hmftools . common . purple . region . FittedRegion decoded = com . hartwig . hmftools . common . purple . region . FittedRegionFile . fromString ( com . hartwig . hmftools . common . purple . region . FittedRegionFile . toString ( expected ) ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( expected , decoded )", "method_name": "toString", "test_name": "testToFromString"}
{"focal_method": "add ( com . machinezoo . sourceafis . Point ) { return new com . machinezoo . sourceafis . Point ( ( ( x ) + ( other . x ) ) , ( ( y ) + ( other . y ) ) ) ; }", "test_method": "iterator ( ) { com . machinezoo . sourceafis . List < com . machinezoo . sourceafis . Cell > l = new com . machinezoo . sourceafis . ArrayList ( ) ; for ( com . machinezoo . sourceafis . Cell c : new com . machinezoo . sourceafis . Cell ( 2 , 3 ) ) l . add ( c ) ; \"<AssertPlaceHolder>\" ; for ( com . machinezoo . sourceafis . Cell c : new com . machinezoo . sourceafis . Cell ( 0 , 3 ) ) org . junit . Assert . fail ( c . toString ( ) ) ; for ( com . machinezoo . sourceafis . Cell c : new com . machinezoo . sourceafis . Cell ( 3 , 0 ) ) org . junit . Assert . fail ( c . toString ( ) ) ; for ( com . machinezoo . sourceafis . Cell c : new com . machinezoo . sourceafis . Cell ( ( - 1 ) , 3 ) ) org . junit . Assert . fail ( c . toString ( ) ) ; for ( com . machinezoo . sourceafis . Cell c : new com . machinezoo . sourceafis . Cell ( 3 , ( - 1 ) ) ) org . junit . Assert . fail ( c . toString ( ) ) ; }", "assertion": "org . junit . Assert . assertEquals ( com . machinezoo . sourceafis . Arrays . asList ( new com . machinezoo . sourceafis . Cell ( 0 , 0 ) , new com . machinezoo . sourceafis . Cell ( 1 , 0 ) , new com . machinezoo . sourceafis . Cell ( 0 , 1 ) , new com . machinezoo . sourceafis . Cell ( 1 , 1 ) , new com . machinezoo . sourceafis . Cell ( 0 , 2 ) , new com . machinezoo . sourceafis . Cell ( 1 , 2 ) ) , l )", "method_name": "add", "test_name": "iterator"}
{"focal_method": "waitForFlowToFinish ( long , long ) { org . drools . runtime . StatefulKnowledgeSession session = getSessionForCurrentContext ( ) ; long endTime = ( java . lang . System . currentTimeMillis ( ) ) + timeout ; synchronized ( session ) { while ( ( ( session . getProcessInstance ( id ) ) != null ) && ( timeout > 0 ) ) { session . wait ( timeout ) ; timeout = endTime - ( java . lang . System . currentTimeMillis ( ) ) ; } } return ! ( getRunningFlows ( ) . contains ( id ) ) ; }", "test_method": "testWaitForFlowThatCannotFinish_shouldReturnFalse ( ) { java . lang . Long pid = service . startFlow ( \"floweventtest\" ) ; service . processEvent ( new org . openengsb . core . api . Event ( \"FirstEvent\" ) ) ; service . startFlow ( \"flowtest\" ) ; boolean finished = service . waitForFlowToFinish ( pid , 400 ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertThat ( finished , org . hamcrest . CoreMatchers . is ( false ) )", "method_name": "waitForFlowToFinish", "test_name": "testWaitForFlowThatCannotFinish_shouldReturnFalse"}
{"focal_method": "getDocument ( ) { return document ; }", "test_method": "testGerritId ( ) { setText ( ( \"I\" + ( org . eclipse . egit . internal . mylyn . CommitHyperlinkDetectorTest . EXAMPLE_ID ) ) ) ; org . eclipse . jface . text . hyperlink . IHyperlink [ ] hyperlinks = detectHyperlinks ( 0 , textViewer . getDocument ( ) . getLength ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertNull ( hyperlinks )", "method_name": "getDocument", "test_name": "testGerritId"}
{"focal_method": "getRelationshipTypeId ( ) { return relationshipTypeId ; }", "test_method": "getRelationshipTypeByUuid_shouldFindObjectGivenValidUuid ( ) { java . lang . String uuid = \"6d9002ea-a96b-4889-af78-82d48c57a110\" ; org . openmrs . RelationshipType relationshipType = org . openmrs . api . context . Context . getPersonService ( ) . getRelationshipTypeByUuid ( uuid ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( 1 , ( ( int ) ( relationshipType . getRelationshipTypeId ( ) ) ) )", "method_name": "getRelationshipTypeId", "test_name": "getRelationshipTypeByUuid_shouldFindObjectGivenValidUuid"}
{"focal_method": "getIndexPath ( ) { return indexPath ; }", "test_method": "testServerGetIndexPath ( ) { System . out . println ( \"testServerGetIndexPath\" ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( config . getIndexPath ( ) , storage . getIndexPath ( ) )", "method_name": "getIndexPath", "test_name": "testServerGetIndexPath"}
{"focal_method": "tableIds ( java . sql . Connection ) { java . sql . DatabaseMetaData metadata = conn . getMetaData ( ) ; java . lang . String [ ] tableTypes = tableTypes ( metadata , this . tableTypes ) ; try ( java . sql . ResultSet rs = metadata . getTables ( catalogPattern ( ) , schemaPattern ( ) , \"%\" , tableTypes ) ) { java . util . List < io . confluent . connect . jdbc . util . TableId > tableIds = new java . util . ArrayList ( ) ; while ( rs . next ( ) ) { java . lang . String catalogName = rs . getString ( 1 ) ; java . lang . String schemaName = rs . getString ( 2 ) ; java . lang . String tableName = rs . getString ( 3 ) ; io . confluent . connect . jdbc . util . TableId tableId = new io . confluent . connect . jdbc . util . TableId ( catalogName , schemaName , tableName ) ; if ( includeTable ( tableId ) ) { tableIds . add ( tableId ) ; } } return tableIds ; } }", "test_method": "testGetTablesSingle ( ) { newDialectFor ( io . confluent . connect . jdbc . dialect . GenericDatabaseDialectTest . TABLE_TYPES , null ) ; db . createTable ( \"test\" , \"id\" , \"INT\" ) ; io . confluent . connect . jdbc . util . TableId test = new io . confluent . connect . jdbc . util . TableId ( null , \"APP\" , \"test\" ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( java . util . Arrays . asList ( test ) , dialect . tableIds ( conn ) )", "method_name": "tableIds", "test_name": "testGetTablesSingle"}
{"focal_method": "getTransaction ( java . lang . String , java . lang . String ) { return null ; }", "test_method": "testGetTransactionsAfterRemoveInvalid ( ) { long initialTime = clock . millis ( ) ; when ( clock . millis ( ) ) . thenReturn ( initialTime , ( initialTime + 1000 ) , ( initialTime + 2000 ) ) ; org . hawkular . apm . api . model . config . txn . TransactionConfig btc1 = new org . hawkular . apm . api . model . config . txn . TransactionConfig ( ) ; btc1 . setDescription ( \"btc1\" ) ; try { cfgs . setTransaction ( null , \"btc1\" , btc1 ) ; } catch ( java . lang . Exception e ) { org . junit . Assert . fail ( ( \"Failed<sp>to<sp>update<sp>btc1:<sp>\" + e ) ) ; } try { cfgs . removeTransaction ( null , \"btc1\" ) ; } catch ( java . lang . Exception e ) { org . junit . Assert . fail ( ( \"Failed<sp>to<sp>remove<sp>btc1:<sp>\" + e ) ) ; } org . hawkular . apm . api . model . config . txn . TransactionConfig btc1again = cfgs . getTransaction ( null , \"btc1\" ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertNull ( btc1again )", "method_name": "getTransaction", "test_name": "testGetTransactionsAfterRemoveInvalid"}
{"focal_method": "getJobStatus ( org . sagebionetworks . repo . model . UserInfo , java . lang . String ) { if ( userInfo == null ) throw new java . lang . IllegalArgumentException ( \"UserInfo<sp>cannot<sp>be<sp>null\" ) ; org . sagebionetworks . repo . model . asynch . AsynchronousJobStatus status = lookupJobStatus ( jobId ) ; if ( ! ( authorizationManager . isUserCreatorOrAdmin ( userInfo , status . getStartedByUserId ( ) . toString ( ) ) ) ) { throw new org . sagebionetworks . repo . model . UnauthorizedException ( \"Only<sp>the<sp>user<sp>that<sp>created<sp>a<sp>job<sp>can<sp>access<sp>the<sp>job's<sp>status.\" ) ; } return status ; }", "test_method": "testGetJobStatusDownProcessing ( ) { when ( mockAuthorizationManager . isUserCreatorOrAdmin ( any ( org . sagebionetworks . repo . model . UserInfo . class ) , anyString ( ) ) ) . thenReturn ( true ) ; when ( mockStackStatusDao . getCurrentStatus ( ) ) . thenReturn ( StatusEnum . DOWN ) ; org . sagebionetworks . repo . model . asynch . AsynchronousJobStatus status = new org . sagebionetworks . repo . model . asynch . AsynchronousJobStatus ( ) ; status . setStartedByUserId ( user . getId ( ) ) ; status . setJobId ( \"999\" ) ; status . setJobState ( AsynchJobState . PROCESSING ) ; when ( mockAsynchJobStatusDao . getJobStatus ( anyString ( ) ) ) . thenReturn ( status ) ; org . sagebionetworks . repo . model . asynch . AsynchronousJobStatus result = manager . getJobStatus ( user , \"999\" ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertNotNull ( result )", "method_name": "getJobStatus", "test_name": "testGetJobStatusDownProcessing"}
{"focal_method": "getGameModes ( ) { return gameModes ; }", "test_method": "testGetGameModes ( ) { \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertTrue ( f . getGameModes ( ) . isEmpty ( ) )", "method_name": "getGameModes", "test_name": "testGetGameModes"}
{"focal_method": "getCardinality ( ) { return ( ( int ) ( getLongCardinality ( ) ) ) ; }", "test_method": "remove ( ) { org . roaringbitmap . Container rc = new org . roaringbitmap . RunContainer ( ) ; rc . add ( ( ( short ) ( 1 ) ) ) ; org . roaringbitmap . Container newContainer = rc . remove ( 1 , 2 ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( 0 , newContainer . getCardinality ( ) )", "method_name": "getCardinality", "test_name": "remove"}
{"focal_method": "getCode ( ) { return code ; }", "test_method": "testEnumNamen ( ) { for ( final nl . moderniseringgba . migratie . Requirements req : nl . moderniseringgba . migratie . Requirements . values ( ) ) { final java . lang . String naamZonderKoppel = req . name ( ) . replaceAll ( \"_\" , \"\" ) . toUpperCase ( ) ; final java . lang . String codeZonderKoppel = req . getCode ( ) . replaceAll ( \"-\" , \"\" ) . toUpperCase ( ) ; \"<AssertPlaceHolder>\" ; } }", "assertion": "org . junit . Assert . assertEquals ( naamZonderKoppel , codeZonderKoppel )", "method_name": "getCode", "test_name": "testEnumNamen"}
{"focal_method": "getDeclaration ( ) { return null ; }", "test_method": "testGetDeclaration ( ) { org . eclipse . tracecompass . ctf . core . event . types . IntegerDeclaration result = fixture . getDeclaration ( ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertNotNull ( result )", "method_name": "getDeclaration", "test_name": "testGetDeclaration"}
{"focal_method": "getPersonVoided ( ) { return personVoided ; }", "test_method": "voidPatient_shouldVoidPerson ( ) { org . openmrs . Patient patient = org . openmrs . api . PatientServiceTest . patientService . getPatient ( 2 ) ; org . openmrs . api . PatientServiceTest . patientService . voidPatient ( patient , \"reason\" ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertTrue ( patient . getPersonVoided ( ) )", "method_name": "getPersonVoided", "test_name": "voidPatient_shouldVoidPerson"}
{"focal_method": "map ( java . util . Set , java . util . Set ) { final java . util . List < nl . moderniseringgba . migratie . conversie . model . brp . BrpRelatie > result = new java . util . ArrayList < nl . moderniseringgba . migratie . conversie . model . brp . BrpRelatie > ( ) ; for ( final nl . moderniseringgba . migratie . synchronisatie . domein . brp . kern . entity . Betrokkenheid ikBetrokkenheid : ikBetrokkenheidSet ) { final nl . moderniseringgba . migratie . synchronisatie . domein . brp . kern . entity . Relatie relatie = ikBetrokkenheid . getRelatie ( ) ; final nl . moderniseringgba . migratie . conversie . model . brp . attribuut . BrpSoortRelatieCode soortRelatieCode = nl . moderniseringgba . migratie . synchronisatie . service . impl . mapper . BrpMapperUtil . mapBrpSoortRelatieCode ( relatie . getSoortRelatie ( ) ) ; final nl . moderniseringgba . migratie . conversie . model . brp . attribuut . BrpSoortBetrokkenheidCode rolCode = nl . moderniseringgba . migratie . synchronisatie . service . impl . mapper . BrpMapperUtil . mapBrpSoortBetrokkenheidCode ( ikBetrokkenheid . getSoortBetrokkenheid ( ) ) ; nl . moderniseringgba . migratie . conversie . model . brp . BrpStapel < nl . moderniseringgba . migratie . conversie . model . brp . groep . BrpRelatieInhoud > relatieStapel = relatieMapper . map ( relatie . getRelatieHistorieSet ( ) ) ; if ( multiRealiteitSet != null ) { for ( final nl . moderniseringgba . migratie . synchronisatie . domein . brp . kern . entity . MultiRealiteitRegel multiRealiteit : multiRealiteitSet ) { if ( ( SoortMultiRealiteitRegel . RELATIE . equals ( multiRealiteit . getSoortMultiRealiteitRegel ( ) ) ) && ( relatie . getId ( ) . equals ( multiRealiteit . getRelatie ( ) . getId ( ) ) ) ) { relatieStapel = brpMultiRealiteitMapper . verwerk ( relatieStapel , multiRealiteit ) ; } } } if ( ( ( nl . moderniseringgba . migratie . conversie . model . brp . attribuut . BrpSoortRelatieCode . HUWELIJK ) == soortRelatieCode ) || ( ( nl . moderniseringgba . migratie . conversie . model . brp . attribuut . BrpSoortRelatieCode . GEREGISTREERD_PARTNERSCHAP ) == soortRelatieCode ) ) { if ( relatieStapel == null ) { continue ; } } final java . util . List < nl . moderniseringgba . migratie . conversie . model . brp . BrpBetrokkenheid > betrokkenheden = new java . util . ArrayList < nl . moderniseringgba . migratie . conversie . model . brp . BrpBetrokkenheid > ( ) ; for ( final nl . moderniseringgba . migratie . synchronisatie . domein . brp . kern . entity . Betrokkenheid betrokkene : relatie . getBetrokkenheidSet ( ) ) { if ( ! ( betrokkene . getId ( ) . equals ( ikBetrokkenheid . getId ( ) ) ) ) { if ( ( ( ikBetrokkenheid . getSoortBetrokkenheid ( ) ) == ( nl . moderniseringgba . migratie . synchronisatie . domein . brp . kern . entity . SoortBetrokkenheid . OUDER ) ) && ( ( betrokkene . getSoortBetrokkenheid ( ) ) == ( nl . moderniseringgba . migratie . synchronisatie . domein . brp . kern . entity . SoortBetrokkenheid . OUDER ) ) ) { continue ; } final nl . moderniseringgba . migratie . conversie . model . brp . BrpBetrokkenheid betrokkenheid = mapBetrokkene ( ikBetrokkenheid , betrokkene , multiRealiteitSet ) ; if ( betrokkenheid == null ) { continue ; } betrokkenheden . add ( betrokkenheid ) ; } } if ( ( betrokkenheden . size ( ) ) > 0 ) { result . add ( new nl . moderniseringgba . migratie . conversie . model . brp . BrpRelatie ( soortRelatieCode , rolCode , betrokkenheden , relatieStapel ) ) ; } } return result ; }", "test_method": "testVoorkomenTbvLeveringMutatie ( ) { final nl . bzk . algemeenbrp . dal . domein . brp . entity . PersoonIndicatieHistorie historie = maakPersoonIndicatieHistorie ( ) ; historie . setIndicatieVoorkomenTbvLeveringMutaties ( Boolean . TRUE ) ; final java . util . Set < nl . bzk . algemeenbrp . dal . domein . brp . entity . PersoonIndicatieHistorie > historieSet = new java . util . HashSet ( ) ; historieSet . add ( historie ) ; final nl . bzk . migratiebrp . conversie . model . brp . BrpStapel < nl . bzk . migratiebrp . conversie . model . brp . groep . BrpSignaleringMetBetrekkingTotVerstrekkenReisdocumentInhoud > result = mapper . map ( historieSet , brpOnderzoekMapper ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertNull ( result )", "method_name": "map", "test_name": "testVoorkomenTbvLeveringMutatie"}
{"focal_method": "fromYamlToJson ( java . lang . String ) { java . lang . Object obj = com . vmware . admiral . common . util . YamlMapper . objectMapper ( ) . readValue ( yaml , java . lang . Object . class ) ; return com . vmware . xenon . common . Utils . toJson ( obj ) ; }", "test_method": "testConvertFromYamlToJson ( ) { java . lang . String yamlInput = \"---\\n\" + ( ( \"person:\\n\" + \"<sp>name:<sp>test-name\\n\" ) + \"<sp>age:<sp>14\\n\" ) ; java . lang . String expectedJsonOutput = \"{\\\"person\\\":{\\\"name\\\":\\\"test-name\\\",\\\"age\\\":14}}\" ; java . lang . String actualJsonOutput = com . vmware . admiral . common . util . YamlMapper . fromYamlToJson ( yamlInput ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( expectedJsonOutput , actualJsonOutput )", "method_name": "fromYamlToJson", "test_name": "testConvertFromYamlToJson"}
{"focal_method": "accept ( int ) { if ( value < ( currentValue ) ) { wrongOrder [ 0 ] = true ; } currentValue = value ; }", "test_method": "testForEach ( ) { final long [ ] expected = new long [ ] { 12L , 32L , 22L , 9L } ; com . annimon . stream . LongStream . of ( 12L , 32L , 22L , 9L ) . forEach ( new com . annimon . stream . function . LongConsumer ( ) { private int index = 0 ; @ com . annimon . stream . longstreamtests . Override public void accept ( long value ) { \"<AssertPlaceHolder>\" ; } } ) ; }", "assertion": "org . junit . Assert . assertThat ( value , org . hamcrest . Matchers . is ( expected [ ( ( index ) ++ ) ] ) )", "method_name": "accept", "test_name": "testForEach"}
{"focal_method": "getFileEntryId ( ) { return com . liferay . upload . web . internal . HTMLImageAttachmentElementReplacerTest . _IMAGE_FILE_ENTRY_ID ; }", "test_method": "testShouldReturnItIfExistsInRootFolder ( ) { com . liferay . portal . kernel . repository . model . FileEntry fileEntry1 = com . liferay . document . library . app . service . test . DLAppServiceTestUtil . addFileEntry ( group . getGroupId ( ) , DLFolderConstants . DEFAULT_PARENT_FOLDER_ID ) ; com . liferay . portal . kernel . repository . model . FileEntry fileEntry2 = com . liferay . document . library . kernel . service . DLAppServiceUtil . getFileEntry ( group . getGroupId ( ) , DLFolderConstants . DEFAULT_PARENT_FOLDER_ID , fileEntry1 . getTitle ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( fileEntry1 . getFileEntryId ( ) , fileEntry2 . getFileEntryId ( ) )", "method_name": "getFileEntryId", "test_name": "testShouldReturnItIfExistsInRootFolder"}
{"focal_method": "getId ( ) { return this . id ; }", "test_method": "testCreate ( ) { org . oscarehr . common . model . MeasurementType entity = new org . oscarehr . common . model . MeasurementType ( ) ; org . oscarehr . common . dao . utils . EntityDataGenerator . generateTestDataForModelClass ( entity ) ; dao . persist ( entity ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertNotNull ( entity . getId ( ) )", "method_name": "getId", "test_name": "testCreate"}
{"focal_method": "hasField ( java . lang . String ) { return fFields . containsKey ( fieldTag ) ; }", "test_method": "testHasField ( ) { fixture . setTag ( \"\" ) ; java . lang . String tag = \"\" ; boolean result = fixture . hasField ( tag ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( false , result )", "method_name": "hasField", "test_name": "testHasField"}
{"focal_method": "needUpgrade ( ) { int appliedTasks = repository . countUpgradeTask ( org . talend . dataprep . upgrade . VERSION . name ( ) ) ; int availableTasks = ( ( int ) ( tasks . stream ( ) . filter ( ( task ) -> java . util . Objects . equals ( task . getTarget ( ) , org . talend . dataprep . upgrade . VERSION ) ) . count ( ) ) ) ; if ( appliedTasks > availableTasks ) { org . talend . dataprep . upgrade . UpgradeService . LOG . warn ( \"It<sp>seems<sp>that<sp>more<sp>upgrade<sp>tasks<sp>have<sp>been<sp>applied<sp>than<sp>the<sp>available<sp>ones.\" ) ; return true ; } else if ( appliedTasks == availableTasks ) { return false ; } else { return true ; } }", "test_method": "shouldNotAllowUpgrade ( ) { when ( repository . countUpgradeTask ( anyString ( ) ) ) . thenReturn ( 1 ) ; final org . talend . dataprep . upgrade . model . UpgradeTask upgradeTask = mock ( org . talend . dataprep . upgrade . model . UpgradeTask . class ) ; when ( upgradeTask . getTarget ( ) ) . thenReturn ( org . talend . dataprep . upgrade . VERSION ) ; service . setTasks ( java . util . Collections . singletonList ( upgradeTask ) ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertFalse ( service . needUpgrade ( ) )", "method_name": "needUpgrade", "test_name": "shouldNotAllowUpgrade"}
{"focal_method": "isSuccess ( ) { if ( ! ( super . isSuccess ( ) ) ) { return false ; } return checkResults ( result ( ) , rawResult . size ( ) , dataSize ) ; }", "test_method": "testBootstrap2 ( ) { final java . util . Random rnd = new java . util . Random ( 42 ) ; net . tomp2p . p2p . Peer master = null ; try { net . tomp2p . p2p . Peer [ ] peers = net . tomp2p . Utils2 . createNodes ( 2000 , rnd , 4001 ) ; master = peers [ 0 ] ; java . util . List < net . tomp2p . futures . FutureBootstrap > tmp = new java . util . ArrayList < net . tomp2p . futures . FutureBootstrap > ( ) ; for ( int i = 0 ; i < ( peers . length ) ; i ++ ) { if ( ( peers [ i ] ) != master ) { net . tomp2p . futures . FutureBootstrap res = peers [ i ] . bootstrap ( ) . peerAddress ( master . peerAddress ( ) ) . start ( ) ; tmp . add ( res ) ; } } int i = 0 ; for ( net . tomp2p . futures . FutureBootstrap fm : tmp ) { fm . awaitUninterruptibly ( ) ; if ( fm . isFailed ( ) ) System . err . println ( ( \"FAILL:\" + ( fm . failedReason ( ) ) ) ) ; \"<AssertPlaceHolder>\" ; System . err . println ( ( \"i:\" + ( ++ i ) ) ) ; } } finally { if ( master != null ) { master . shutdown ( ) . await ( ) ; } } }", "assertion": "org . junit . Assert . assertEquals ( true , fm . isSuccess ( ) )", "method_name": "isSuccess", "test_name": "testBootstrap2"}
{"focal_method": "convert ( java . lang . String ) { final java . util . regex . Matcher matcher = org . fcrepo . http . commons . domain . Range . rangePattern . matcher ( source ) ; if ( ! ( matcher . matches ( ) ) ) { return new org . fcrepo . http . commons . domain . Range ( ) ; } final java . lang . String from = matcher . group ( 1 ) ; final java . lang . String to = matcher . group ( 2 ) ; final long start ; if ( from . equals ( \"\" ) ) { start = 0 ; } else { start = java . lang . Long . parseLong ( from ) ; } final long end ; if ( to . equals ( \"\" ) ) { end = - 1 ; } else { end = java . lang . Long . parseLong ( to ) ; } return new org . fcrepo . http . commons . domain . Range ( start , end ) ; }", "test_method": "testDoBackwardWithDatastreamContent ( ) { when ( node . isNodeType ( org . fcrepo . http . commons . api . rdf . FEDORA_BINARY ) ) . thenReturn ( true ) ; final org . apache . jena . rdf . model . Resource converted = converter . reverse ( ) . convert ( new org . fcrepo . kernel . modeshape . FedoraBinaryImpl ( node ) ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( resource , converted )", "method_name": "convert", "test_name": "testDoBackwardWithDatastreamContent"}
{"focal_method": "exist ( java . lang . String ) { org . ff4j . utils . Util . assertHasLength ( uid ) ; return getFeatureBucket ( ) . exists ( uid ) ; }", "test_method": "testImportFeatures ( ) { testedStore . importFeatures ( null ) ; org . ff4j . core . Feature fx1 = new org . ff4j . core . Feature ( \"fx1\" , true ) ; org . ff4j . core . Feature fx2 = new org . ff4j . core . Feature ( \"fx2\" , true ) ; testedStore . importFeatures ( org . ff4j . utils . Util . list ( fx1 , fx2 ) ) ; \"<AssertPlaceHolder>\" ; testedStore . importFeatures ( org . ff4j . utils . Util . list ( fx1 , fx2 ) ) ; }", "assertion": "org . junit . Assert . assertTrue ( testedStore . exist ( \"fx1\" ) )", "method_name": "exist", "test_name": "testImportFeatures"}
{"focal_method": "isExpired ( long ) { java . util . Date current = new java . util . Date ( ) ; long currentDate = current . getTime ( ) ; long hours = currentDate - pwdRecoveryStartDate ; return hours > ( org . oscm . internal . passwordrecovery . PasswordRecoveryValidator . EXPIRY ) ; }", "test_method": "isExpired_Failed ( ) { java . util . Date current = new java . util . Date ( ) ; long time = current . getTime ( ) ; time = time - 86400020 ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( true , org . oscm . internal . passwordrecovery . PasswordRecoveryValidator . isExpired ( time ) )", "method_name": "isExpired", "test_name": "isExpired_Failed"}
{"focal_method": "get ( java . lang . String ) { return map . get ( name ) ; }", "test_method": "updateTypeEntityOnDepA ( ) { waitForSync ( ) ; com . google . appengine . api . datastore . Key key = com . google . appengine . api . datastore . KeyFactory . createKey ( \"UPDATE\" , 1 ) ; com . google . appengine . api . datastore . Entity lookup = getService ( ) . get ( key ) ; \"<AssertPlaceHolder>\" ; lookup . setProperty ( \"type\" , \"DONE\" ) ; getService ( ) . put ( lookup ) ; }", "assertion": "org . junit . Assert . assertNotNull ( lookup )", "method_name": "get", "test_name": "updateTypeEntityOnDepA"}
{"focal_method": "build ( java . lang . String , java . lang . String ) { org . apache . jena . rdf . model . Resource type = org . apache . jena . rdf . model . ResourceFactory . createResource ( typeURI ) ; return org . apache . jena . sparql . core . assembler . AssemblerUtils . build ( assemblerFile , type ) ; }", "test_method": "dsg1_bad_1 ( ) { org . apache . jena . query . Dataset ds = ( ( org . apache . jena . query . Dataset ) ( org . apache . jena . sparql . core . assembler . AssemblerUtils . build ( ( ( org . apache . jena . test . assembler . TestDatasetAssembler . DIR ) + \"assem_dsg1_bad_1.ttl\" ) , DatasetAssemblerVocab . tDatasetOne ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertNotNull ( ds )", "method_name": "build", "test_name": "dsg1_bad_1"}
{"focal_method": "fromYml ( java . lang . String , java . lang . reflect . Type ) { java . util . Map result = com . flow . platform . yml . parser . YmlParser . ymlToMap ( str ) ; return com . flow . platform . yml . parser . YmlParser . fromObject ( result . get ( \"flow\" ) , typeOfT ) ; }", "test_method": "should_required ( ) { java . lang . String demo = loadDemoFlowYaml ( \"demo-yml.yaml\" ) ; try { com . flow . platform . yml . parser . test . domain . FlowTestRequired [ ] flows = com . flow . platform . yml . parser . YmlParser . fromYml ( demo , com . flow . platform . yml . parser . test . domain . FlowTestRequired [ ] . class ) ; } catch ( com . flow . platform . yml . parser . exception . YmlParseException e ) { \"<AssertPlaceHolder>\" ; } }", "assertion": "org . junit . Assert . assertEquals ( com . flow . platform . yml . parser . exception . YmlParseException . class , e . getClass ( ) )", "method_name": "fromYml", "test_name": "should_required"}
{"focal_method": "eval ( java . lang . String ) { return getValue ( expression , java . lang . Object . class ) ; }", "test_method": "testMod02 ( ) { javax . el . ELProcessor processor = new javax . el . ELProcessor ( ) ; java . lang . Object result = processor . eval ( \"null<sp>%<sp>null\" ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( java . lang . Long . valueOf ( 0 ) , result )", "method_name": "eval", "test_name": "testMod02"}
{"focal_method": "isEmpty ( ) { return map . isEmpty ( ) ; }", "test_method": "testGetDirectChildrenFromLeaf_shouldReturnEmptyList ( ) { java . util . List < org . apache . directory . shared . ldap . model . entry . Entry > children = dao . getDirectChildren ( baseDn ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertThat ( children . isEmpty ( ) , org . hamcrest . Matchers . is ( true ) )", "method_name": "isEmpty", "test_name": "testGetDirectChildrenFromLeaf_shouldReturnEmptyList"}
{"focal_method": "createBrpPersoonslijstMissing ( nl . moderniseringgba . migratie . conversie . model . brp . attribuut . BrpGemeenteCode ) { final nl . moderniseringgba . migratie . conversie . model . brp . attribuut . BrpGemeenteCode brpGemeenteCode = gemeenteCode ; final nl . moderniseringgba . migratie . conversie . model . brp . BrpPersoonslijstBuilder builder = new nl . moderniseringgba . migratie . conversie . model . brp . BrpPersoonslijstBuilder ( ) ; final java . util . List < nl . moderniseringgba . migratie . conversie . model . brp . BrpGroep < nl . moderniseringgba . migratie . conversie . model . brp . groep . BrpBijhoudingsgemeenteInhoud > > groepen = new java . util . ArrayList < nl . moderniseringgba . migratie . conversie . model . brp . BrpGroep < nl . moderniseringgba . migratie . conversie . model . brp . groep . BrpBijhoudingsgemeenteInhoud > > ( ) ; groepen . add ( new nl . moderniseringgba . migratie . conversie . model . brp . BrpGroep < nl . moderniseringgba . migratie . conversie . model . brp . groep . BrpBijhoudingsgemeenteInhoud > ( new nl . moderniseringgba . migratie . conversie . model . brp . groep . BrpBijhoudingsgemeenteInhoud ( brpGemeenteCode , nl . moderniseringgba . migratie . conversie . model . brp . attribuut . BrpDatum . ONBEKEND , false ) , new nl . moderniseringgba . migratie . conversie . model . brp . BrpHistorie ( new nl . moderniseringgba . migratie . conversie . model . brp . attribuut . BrpDatum ( 20000101 ) , new nl . moderniseringgba . migratie . conversie . model . brp . attribuut . BrpDatum ( 20110101 ) , new nl . moderniseringgba . migratie . conversie . model . brp . attribuut . BrpDatumTijd ( new java . util . Date ( ) ) , new nl . moderniseringgba . migratie . conversie . model . brp . attribuut . BrpDatumTijd ( new java . util . Date ( ) ) ) , null , null , null ) ) ; builder . bijhoudingsgemeenteStapel ( new nl . moderniseringgba . migratie . conversie . model . brp . BrpStapel < nl . moderniseringgba . migratie . conversie . model . brp . groep . BrpBijhoudingsgemeenteInhoud > ( groepen ) ) ; return builder . build ( ) ; }", "test_method": "testSorteerPLLegeStapel ( ) { final nl . bzk . migratiebrp . conversie . model . brp . BrpPersoonslijst pl = nl . bzk . migratiebrp . ggo . viewer . GgoBrpStapelSorter . sorteerPersoonslijst ( createBrpPersoonslijstMissing ( new nl . bzk . migratiebrp . conversie . model . brp . attribuut . BrpGemeenteCode ( ( ( short ) ( 1904 ) ) ) ) , foutMelder ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertNotNull ( pl )", "method_name": "createBrpPersoonslijstMissing", "test_name": "testSorteerPLLegeStapel"}
{"focal_method": "compareTo ( opennlp . tools . util . Span ) { if ( ( getStart ( ) ) < ( s . getStart ( ) ) ) { return - 1 ; } else if ( ( getStart ( ) ) == ( s . getStart ( ) ) ) { if ( ( getEnd ( ) ) > ( s . getEnd ( ) ) ) { return - 1 ; } else if ( ( getEnd ( ) ) < ( s . getEnd ( ) ) ) { return 1 ; } else { if ( ( ( getType ( ) ) == null ) && ( ( s . getType ( ) ) == null ) ) { return 0 ; } else if ( ( ( getType ( ) ) != null ) && ( ( s . getType ( ) ) != null ) ) { return getType ( ) . compareTo ( s . getType ( ) ) ; } else if ( ( getType ( ) ) != null ) { return - 1 ; } return 1 ; } } else { return 1 ; } }", "test_method": "testCompareToHigher ( ) { opennlp . tools . util . Span a = new opennlp . tools . util . Span ( 100 , 200 ) ; opennlp . tools . util . Span b = new opennlp . tools . util . Span ( 300 , 400 ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( true , ( ( a . compareTo ( b ) ) < 0 ) )", "method_name": "compareTo", "test_name": "testCompareToHigher"}
{"focal_method": "getId ( ) { return id ; }", "test_method": "testLookupBlob ( ) { final java . io . File repoPath = setupRepository ( \"testrepo\" ) ; org . libgit2 . jagged . Repository repository = new org . libgit2 . jagged . Repository ( repoPath . getAbsolutePath ( ) ) ; org . libgit2 . jagged . ObjectId oid = new org . libgit2 . jagged . ObjectId ( \"dc48b6c38e967e57965e36c6f7a1c3ec5c3e1ff4\" ) ; org . libgit2 . jagged . Blob blob = repository . lookup ( oid ) ; \"<AssertPlaceHolder>\" ; repository . close ( ) ; }", "assertion": "org . junit . Assert . assertEquals ( oid , blob . getId ( ) )", "method_name": "getId", "test_name": "testLookupBlob"}
{"focal_method": "setOrders ( java . util . List ) { this . orders = orders ; }", "test_method": "testBuildWithOrderBy ( ) { org . lnu . is . domain . employee . status . EmployeeStatus context = new org . lnu . is . domain . employee . status . EmployeeStatus ( ) ; org . lnu . is . pagination . OrderBy orderBy1 = new org . lnu . is . pagination . OrderBy ( \"abbrName\" , org . lnu . is . pagination . OrderByType . ASC ) ; org . lnu . is . pagination . OrderBy orderBy2 = new org . lnu . is . pagination . OrderBy ( \"name\" , org . lnu . is . pagination . OrderByType . DESC ) ; java . util . List < org . lnu . is . pagination . OrderBy > orders = java . util . Arrays . asList ( orderBy1 , orderBy2 ) ; java . lang . String expectedQuery = \"SELECT<sp>e<sp>FROM<sp>EmployeeStatus<sp>e<sp>WHERE<sp>e.status=:status<sp>AND<sp>e.crtUserGroup<sp>IN<sp>(:userGroups)<sp>ORDER<sp>BY<sp>e.abbrName<sp>ASC,<sp>e.name<sp>DESC\" ; org . lnu . is . pagination . MultiplePagedSearch < org . lnu . is . domain . employee . status . EmployeeStatus > pagedSearch = new org . lnu . is . pagination . MultiplePagedSearch ( ) ; pagedSearch . setEntity ( context ) ; pagedSearch . setOrders ( orders ) ; java . lang . String actualQuery = unit . build ( pagedSearch ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( expectedQuery , actualQuery )", "method_name": "setOrders", "test_name": "testBuildWithOrderBy"}
{"focal_method": "next ( ) { if ( isClosed ) { throw new java . sql . SQLException ( \"Operation<sp>not<sp>permit<sp>on<sp>a<sp>closed<sp>resultSet\" , \"HY000\" ) ; } if ( ( rowPointer ) < ( ( dataSize ) - 1 ) ) { ( rowPointer ) ++ ; return true ; } else { if ( ( streaming ) && ( ! ( isEof ) ) ) { lock . lock ( ) ; try { if ( ! ( isEof ) ) { nextStreamingValue ( ) ; } } catch ( java . io . IOException ioe ) { throw handleIoException ( ioe ) ; } finally { lock . unlock ( ) ; } if ( ( resultSetScrollType ) == ( TYPE_FORWARD_ONLY ) ) { rowPointer = 0 ; return ( dataSize ) > 0 ; } else { ( rowPointer ) ++ ; return ( dataSize ) > ( rowPointer ) ; } } rowPointer = dataSize ; return false ; } }", "test_method": "timeTest3 ( ) { java . sql . Statement stmt = sharedConnection . createStatement ( ) ; java . sql . ResultSet rs = stmt . executeQuery ( \"select<sp>'aaa'<sp>as<sp>a\" ) ; \"<AssertPlaceHolder>\" ; rs . getTimestamp ( \"a\" ) ; }", "assertion": "org . junit . Assert . assertTrue ( rs . next ( ) )", "method_name": "next", "test_name": "timeTest3"}
{"focal_method": "next ( int ) { java . lang . StringBuilder sb = new java . lang . StringBuilder ( uri ) ; sb . append ( \"?n=\" ) ; sb . append ( nbRows ) ; for ( int i = 0 ; i < ( maxRetries ) ; i ++ ) { org . apache . hadoop . hbase . rest . client . Response response = client . get ( sb . toString ( ) , Constants . MIMETYPE_PROTOBUF ) ; int code = response . getCode ( ) ; switch ( code ) { case 200 : org . apache . hadoop . hbase . rest . model . CellSetModel model = new org . apache . hadoop . hbase . rest . model . CellSetModel ( ) ; model . getObjectFromMessage ( response . getBody ( ) ) ; return buildResultFromModel ( model ) ; case 204 : case 206 : return null ; case 509 : try { java . lang . Thread . sleep ( sleepTime ) ; } catch ( java . lang . InterruptedException e ) { throw ( ( java . io . InterruptedIOException ) ( new java . io . InterruptedIOException ( ) . initCause ( e ) ) ) ; } break ; default : throw new java . io . IOException ( ( \"scanner.next<sp>request<sp>failed<sp>with<sp>\" + code ) ) ; } } throw new java . io . IOException ( \"scanner.next<sp>request<sp>timed<sp>out\" ) ; }", "test_method": "testMixedDeletes ( ) { java . util . List < org . apache . hadoop . hbase . shaded . protobuf . generated . AdminProtos . WALEntry > entries = new java . util . ArrayList ( 3 ) ; java . util . List < org . apache . hadoop . hbase . Cell > cells = new java . util . ArrayList ( ) ; for ( int i = 0 ; i < 3 ; i ++ ) { entries . add ( createEntry ( org . apache . hadoop . hbase . replication . regionserver . TestReplicationSink . TABLE_NAME1 , i , KeyValue . Type . Put , cells ) ) ; } org . apache . hadoop . hbase . replication . regionserver . TestReplicationSink . SINK . replicateEntries ( entries , org . apache . hadoop . hbase . CellUtil . createCellScanner ( cells . iterator ( ) ) , org . apache . hadoop . hbase . replication . regionserver . TestReplicationSink . replicationClusterId , org . apache . hadoop . hbase . replication . regionserver . TestReplicationSink . baseNamespaceDir , org . apache . hadoop . hbase . replication . regionserver . TestReplicationSink . hfileArchiveDir ) ; entries = new java . util . ArrayList ( 3 ) ; cells = new java . util . ArrayList ( ) ; entries . add ( createEntry ( org . apache . hadoop . hbase . replication . regionserver . TestReplicationSink . TABLE_NAME1 , 0 , KeyValue . Type . DeleteColumn , cells ) ) ; entries . add ( createEntry ( org . apache . hadoop . hbase . replication . regionserver . TestReplicationSink . TABLE_NAME1 , 1 , KeyValue . Type . DeleteFamily , cells ) ) ; entries . add ( createEntry ( org . apache . hadoop . hbase . replication . regionserver . TestReplicationSink . TABLE_NAME1 , 2 , KeyValue . Type . DeleteColumn , cells ) ) ; org . apache . hadoop . hbase . replication . regionserver . TestReplicationSink . SINK . replicateEntries ( entries , org . apache . hadoop . hbase . CellUtil . createCellScanner ( cells . iterator ( ) ) , org . apache . hadoop . hbase . replication . regionserver . TestReplicationSink . replicationClusterId , org . apache . hadoop . hbase . replication . regionserver . TestReplicationSink . baseNamespaceDir , org . apache . hadoop . hbase . replication . regionserver . TestReplicationSink . hfileArchiveDir ) ; org . apache . hadoop . hbase . client . Scan scan = new org . apache . hadoop . hbase . client . Scan ( ) ; org . apache . hadoop . hbase . client . ResultScanner scanRes = org . apache . hadoop . hbase . replication . regionserver . TestReplicationSink . table1 . getScanner ( scan ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( 0 , scanRes . next ( 3 ) . length )", "method_name": "next", "test_name": "testMixedDeletes"}
{"focal_method": "process ( co . aurasphere . botmill . fb . model . incoming . MessageEnvelope ) { if ( ( this . event ) == null ) { return false ; } boolean triggered = this . event . verifyEventCondition ( envelope ) ; if ( triggered ) { beforeReply ( envelope ) ; if ( ( this . reply ) != null ) { this . reply . reply ( envelope ) ; } afterReply ( envelope ) ; } return triggered ; }", "test_method": "testAnnotatedButtonTemplateBot ( ) { java . lang . String json = \"{\\\"sender\\\":{\\\"id\\\":\\\"1158621824216736\\\"},\\\"recipient\\\":{\\\"id\\\":\\\"1226565047419159\\\"},\\\"timestamp\\\":1490832021661,\\\"message\\\":{\\\"mid\\\":\\\"mid.$cAAUPCFn4ymdhTcignVbHH3rzpKd_\\\",\\\"seq\\\":844819,\\\"text\\\":\\\"button<sp>template\\\"}}\" ; co . aurasphere . botmill . fb . model . incoming . MessageEnvelope envelope = co . aurasphere . botmill . fb . internal . util . json . FbBotMillJsonUtils . fromJson ( json , co . aurasphere . botmill . fb . model . incoming . MessageEnvelope . class ) ; co . aurasphere . botmill . fb . model . incoming . handler . IncomingToOutgoingMessageHandler . getInstance ( ) . process ( envelope ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertNotNull ( envelope )", "method_name": "process", "test_name": "testAnnotatedButtonTemplateBot"}
{"focal_method": "getScript ( javax . faces . component . behavior . ClientBehaviorContext , javax . faces . component . behavior . ClientBehavior ) { java . lang . String script = null ; if ( ( behavior instanceof org . ajax4jsf . component . behavior . AjaxBehavior ) && ( ! ( ( ( org . ajax4jsf . component . behavior . AjaxBehavior ) ( behavior ) ) . isDisabled ( ) ) ) ) { script = buildAjaxCommand ( behaviorContext , ( ( org . ajax4jsf . component . behavior . AjaxBehavior ) ( behavior ) ) ) ; } return script ; }", "test_method": "testGetScriptOverrideAnnotation ( ) { java . util . Map < java . lang . Class < ? > , org . richfaces . javascript . LibraryFunction > defaultMapping = com . google . common . collect . ImmutableMap . < java . lang . Class < ? > , org . richfaces . javascript . LibraryFunction > of ( org . richfaces . validator . ValidatorWithFacesResource . class , function ) ; serviceImpl = new org . richfaces . javascript . ClientScriptServiceImpl ( defaultMapping ) ; org . richfaces . javascript . LibraryFunction script = getScript ( null , org . richfaces . validator . ValidatorWithFacesResource . class ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertSame ( function , script )", "method_name": "getScript", "test_name": "testGetScriptOverrideAnnotation"}
