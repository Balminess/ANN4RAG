{"focal_method": "getLibraries ( com . day . cq . wcm . api . designer . Design , com . adobe . acs . commons . designer . PageRegion ) { final java . lang . String [ ] cssLibs = this . getCssLibraries ( design , pageRegion ) ; final java . lang . String [ ] jsLibs = this . getJsLibraries ( design , pageRegion ) ; final java . util . LinkedHashSet < java . lang . String > libs = new java . util . LinkedHashSet < java . lang . String > ( ) ; libs . addAll ( java . util . Arrays . asList ( cssLibs ) ) ; libs . addAll ( java . util . Arrays . asList ( jsLibs ) ) ; return libs . toArray ( new java . lang . String [ libs . size ( ) ] ) ; }", "test_method": "testGetLibrariesDoesDeDuplication ( ) { when ( design . getContentResource ( ) ) . thenReturn ( designContentResource ) ; setLibraries ( designContentResource , PageRegion . HEAD , new java . lang . String [ ] { \"css1\" , \"cssandjs1\" } , new java . lang . String [ ] { \"js1\" , \"cssandjs1\" } ) ; java . lang . String [ ] categories = instance . getLibraries ( design , PageRegion . HEAD ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertArrayEquals ( new java . lang . Object [ ] { \"css1\" , \"cssandjs1\" , \"js1\" } , categories )", "method_name": "getLibraries", "test_name": "testGetLibrariesDoesDeDuplication"}
{"focal_method": "getUsersWaitingNotification ( net . jforum . entities . Topic ) { java . util . List < net . jforum . entities . User > users = session . createQuery ( ( \"select<sp>u<sp>from<sp>TopicWatch<sp>tw<sp>\" + ( \"<sp>inner<sp>join<sp>tw.user<sp>u<sp>where<sp>tw.topic<sp>=<sp>:topic<sp>\" + \"<sp>and<sp>(tw.read<sp>=<sp>true<sp>or<sp>u.notifyAlways<sp>=<sp>true)\" ) ) ) . setEntity ( \"topic\" , topic ) . setComment ( \"topicWatchDAO.getUsersWaitingNotification\" ) . list ( ) ; if ( ( users . size ( ) ) > 0 ) { this . markAllAsUnread ( topic ) ; } return users ; }", "test_method": "getUsersWaitingNotificationNoWatchExpectEmptyList ( ) { net . jforum . repository . TopicWatchRepository dao = this . newDao ( ) ; net . jforum . entities . Topic topic = new net . jforum . entities . Topic ( ) ; topic . setId ( 13 ) ; java . util . List < net . jforum . entities . User > users = dao . getUsersWaitingNotification ( topic ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( 0 , users . size ( ) )", "method_name": "getUsersWaitingNotification", "test_name": "getUsersWaitingNotificationNoWatchExpectEmptyList"}
{"focal_method": "getCreator ( ) { if ( ( creator ) == null ) { creator = new de . sstoehr . harreader . model . HarCreatorBrowser ( ) ; } return creator ; }", "test_method": "testCreatorNull ( ) { de . sstoehr . harreader . model . HarLog log = new de . sstoehr . harreader . model . HarLog ( ) ; log . setCreator ( null ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertNotNull ( log . getCreator ( ) )", "method_name": "getCreator", "test_name": "testCreatorNull"}
{"focal_method": "getMutationCoverage ( ) { return ( this . numberOfMutations ) == 0 ? 100 : java . lang . Math . round ( ( ( 100.0F * ( this . numberOfMutationsDetected ) ) / ( this . numberOfMutations ) ) ) ; }", "test_method": "shouldCorrectlyCalculateMutationsCoverageWhenAllMutationsDetected ( ) { this . testee . addMutations ( 100 ) ; this . testee . addMutationsDetetcted ( 100 ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( 100 , this . testee . getMutationCoverage ( ) )", "method_name": "getMutationCoverage", "test_name": "shouldCorrectlyCalculateMutationsCoverageWhenAllMutationsDetected"}
{"focal_method": "performTest ( ) { createCredentialCache ( getClientPrincipal ( ) , getClientPassword ( ) ) ; org . apache . kerby . kerberos . kerb . type . ticket . TgtTicket tgt ; org . apache . kerby . kerberos . kerb . client . KrbTokenClient tokenClient = getTokenClient ( ) ; try { tgt = tokenClient . requestTgt ( getKrbToken ( ) , getcCacheFile ( ) . getPath ( ) ) ; } catch ( org . apache . kerby . kerberos . kerb . KrbException e ) { if ( e . getMessage ( ) . contains ( \"timeout\" ) ) { return ; } throw e ; } verifyTicket ( tgt ) ; org . apache . kerby . kerberos . kerb . type . ticket . SgtTicket tkt = getKrbClient ( ) . requestSgt ( tgt , getServerPrincipal ( ) ) ; verifyTicket ( tkt ) ; }", "test_method": "testBadIssuer ( ) { java . security . PrivateKey privateKey ; try ( java . io . InputStream is = org . apache . kerby . kerberos . kdc . TokenKdcTestBase . class . getResourceAsStream ( \"/private_key.pem\" ) ) { privateKey = org . apache . kerby . kerberos . kerb . common . PrivateKeyReader . loadPrivateKey ( is ) ; } prepareToken ( getServerPrincipal ( ) , \"oauth1.com\" , privateKey , null ) ; try { performTest ( ) ; org . junit . Assert . fail ( \"Failure<sp>expected<sp>on<sp>a<sp>bad<sp>issuer<sp>value\" ) ; } catch ( java . lang . Exception ex ) { \"<AssertPlaceHolder>\" ; } }", "assertion": "org . junit . Assert . assertTrue ( ( ex instanceof org . apache . kerby . kerberos . kerb . KrbException ) )", "method_name": "performTest", "test_name": "testBadIssuer"}
{"focal_method": "successStatusIs200 ( ) { return true ; }", "test_method": "defaultSuccessStatusIs200ForGET ( ) { org . locationtech . geowave . core . cli . api . ServiceEnableCommandTest . ServiceEnabledCommand_TESTING classUnderTest = new org . locationtech . geowave . core . cli . api . ServiceEnableCommandTest . ServiceEnabledCommand_TESTING ( org . locationtech . geowave . core . cli . api . ServiceEnabledCommand . HttpMethod . GET ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( true , classUnderTest . successStatusIs200 ( ) )", "method_name": "successStatusIs200", "test_name": "defaultSuccessStatusIs200ForGET"}
{"focal_method": "create ( T ) { checkForInitialized ( ) ; if ( data == null ) { return 0 ; } if ( data instanceof com . j256 . ormlite . misc . BaseDaoEnabled ) { @ com . j256 . ormlite . dao . SuppressWarnings ( \"unchecked\" ) com . j256 . ormlite . misc . BaseDaoEnabled < T , ID > daoEnabled = ( ( com . j256 . ormlite . misc . BaseDaoEnabled < T , ID > ) ( data ) ) ; daoEnabled . setDao ( this ) ; } com . j256 . ormlite . support . DatabaseConnection connection = connectionSource . getReadWriteConnection ( tableInfo . getTableName ( ) ) ; try { return statementExecutor . create ( connection , data , objectCache ) ; } finally { connectionSource . releaseConnection ( connection ) ; } }", "test_method": "testEnumInt ( ) { java . lang . Class < com . j256 . ormlite . field . types . EnumIntegerTypeTest . LocalEnumInt > clazz = com . j256 . ormlite . field . types . EnumIntegerTypeTest . LocalEnumInt . class ; com . j256 . ormlite . dao . Dao < com . j256 . ormlite . field . types . EnumIntegerTypeTest . LocalEnumInt , java . lang . Object > dao = createDao ( clazz , true ) ; com . j256 . ormlite . field . types . EnumIntegerTypeTest . OurEnum val = com . j256 . ormlite . field . types . EnumIntegerTypeTest . OurEnum . SECOND ; int sqlVal = val . ordinal ( ) ; java . lang . String valStr = java . lang . Integer . toString ( sqlVal ) ; com . j256 . ormlite . field . types . EnumIntegerTypeTest . LocalEnumInt foo = new com . j256 . ormlite . field . types . EnumIntegerTypeTest . LocalEnumInt ( ) ; foo . ourEnum = val ; \"<AssertPlaceHolder>\" ; testType ( dao , foo , clazz , val , sqlVal , sqlVal , valStr , DataType . ENUM_INTEGER , com . j256 . ormlite . field . types . EnumIntegerTypeTest . ENUM_COLUMN , false , true , false , false , false , false , true , false ) ; }", "assertion": "org . junit . Assert . assertEquals ( 1 , dao . create ( foo ) )", "method_name": "create", "test_name": "testEnumInt"}
{"focal_method": "size ( ) { return this . cells . size ( ) ; }", "test_method": "numberedRgroupSymbol ( ) { org . openscience . cdk . renderer . generators . standard . AtomSymbol atomSymbol = atomGenerator . generatePseudoSymbol ( \"R1\" , HydrogenPosition . Right ) ; java . util . List < java . awt . Shape > shapes = atomSymbol . getOutlines ( ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertThat ( shapes . size ( ) , org . hamcrest . CoreMatchers . is ( 2 ) )", "method_name": "size", "test_name": "numberedRgroupSymbol"}
{"focal_method": "getGUID ( java . lang . String ) { return new fr . gouv . vitam . common . guid . GUIDImpl ( guid ) ; }", "test_method": "testGetGUIDByteArray ( ) { byte [ ] baguid = null ; fr . gouv . vitam . common . guid . GUID guid = null ; try { guid = fr . gouv . vitam . common . guid . GUIDReader . getGUID ( fr . gouv . vitam . common . guid . GUIDReaderTest . BASE32 ) ; baguid = guid . getBytes ( ) ; } catch ( final fr . gouv . vitam . common . exception . InvalidGuidOperationException e ) { fr . gouv . vitam . common . guid . GUIDReaderTest . LOGGER . error ( ResourcesPublicUtilTest . SHOULD_NOT_HAVE_AN_EXCEPTION , e ) ; org . junit . Assert . fail ( ResourcesPublicUtilTest . SHOULD_NOT_HAVE_AN_EXCEPTION ) ; } try { final fr . gouv . vitam . common . guid . GUID bguid = fr . gouv . vitam . common . guid . GUIDReader . getGUID ( baguid ) ; \"<AssertPlaceHolder>\" ; } catch ( final fr . gouv . vitam . common . exception . InvalidGuidOperationException e ) { fr . gouv . vitam . common . guid . GUIDReaderTest . LOGGER . error ( ResourcesPublicUtilTest . SHOULD_NOT_HAVE_AN_EXCEPTION , e ) ; org . junit . Assert . fail ( ResourcesPublicUtilTest . SHOULD_NOT_HAVE_AN_EXCEPTION ) ; } try { fr . gouv . vitam . common . guid . GUIDReader . getGUID ( ( ( byte [ ] ) ( null ) ) ) ; org . junit . Assert . fail ( ResourcesPublicUtilTest . SHOULD_HAVE_AN_EXCEPTION ) ; } catch ( final fr . gouv . vitam . common . exception . InvalidGuidOperationException e ) { } try { fr . gouv . vitam . common . guid . GUIDReader . getGUID ( new byte [ 0 ] ) ; org . junit . Assert . fail ( ResourcesPublicUtilTest . SHOULD_HAVE_AN_EXCEPTION ) ; } catch ( final fr . gouv . vitam . common . exception . InvalidGuidOperationException e ) { } try { final byte [ ] ba = new byte [ ] { 1 , 2 } ; fr . gouv . vitam . common . guid . GUIDReader . getGUID ( ba ) ; org . junit . Assert . fail ( ResourcesPublicUtilTest . SHOULD_HAVE_AN_EXCEPTION ) ; } catch ( final fr . gouv . vitam . common . exception . InvalidGuidOperationException e ) { } }", "assertion": "org . junit . Assert . assertEquals ( bguid , guid )", "method_name": "getGUID", "test_name": "testGetGUIDByteArray"}
{"focal_method": "getImages ( ) { return this . images ; }", "test_method": "testGetImagesWhenImageClassificationIsNotOnUrlClient ( ) { com . ontotext . s4 . model . annotation . AnnotatedDocument doc = com . ontotext . s4 . service . impl . S4AnnotationClientTest . apiUrl . annotateDocument ( com . ontotext . s4 . service . impl . S4AnnotationClientTest . imageURL , SupportedMimeType . HTML ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertNull ( doc . getImages ( ) )", "method_name": "getImages", "test_name": "testGetImagesWhenImageClassificationIsNotOnUrlClient"}
{"focal_method": "convertAll ( java . util . List ) { return convertAll ( sources , new java . util . ArrayList < TARGET > ( sources . size ( ) ) ) ; }", "test_method": "testConvertAll ( ) { org . lnu . is . domain . degree . Degree source = new org . lnu . is . domain . degree . Degree ( ) ; java . util . List < org . lnu . is . domain . degree . Degree > sources = java . util . Arrays . asList ( source ) ; org . lnu . is . resource . degree . DegreeResource expected = new org . lnu . is . resource . degree . DegreeResource ( ) ; java . util . List < org . lnu . is . resource . degree . DegreeResource > expecteds = java . util . Arrays . asList ( expected ) ; java . util . List < org . lnu . is . resource . degree . DegreeResource > actuals = unit . convertAll ( sources ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( expecteds , actuals )", "method_name": "convertAll", "test_name": "testConvertAll"}
{"focal_method": "getLocalValue ( ) { return null ; }", "test_method": "testClone ( ) { org . apache . flink . api . common . accumulators . DoubleMinimum min = new org . apache . flink . api . common . accumulators . DoubleMinimum ( ) ; double value = 3.14159265359 ; min . add ( value ) ; org . apache . flink . api . common . accumulators . DoubleMinimum clone = min . clone ( ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( value , clone . getLocalValue ( ) , 0.0 )", "method_name": "getLocalValue", "test_name": "testClone"}
{"focal_method": "getFailed ( ) { return m_failed ; }", "test_method": "testTwentySwitchTopologyVRendMun ( ) { org . opennms . netmgt . enlinkd . TwentyNodeTopology topology = new org . opennms . netmgt . enlinkd . TwentyNodeTopology ( ) ; org . opennms . netmgt . enlinkd . service . api . BroadcastDomain domain = new org . opennms . netmgt . enlinkd . service . api . BroadcastDomain ( ) ; org . opennms . netmgt . enlinkd . service . api . Bridge . create ( domain , topology . vrendmunalv02Id ) ; org . opennms . netmgt . enlinkd . service . api . Bridge . create ( domain , topology . vrendmunasw01Id ) ; org . opennms . netmgt . enlinkd . service . api . Bridge . create ( domain , topology . comunevillarendenawl1Id ) ; setBridgeElements ( domain , topology . elemlist ) ; org . opennms . netmgt . enlinkd . service . api . DiscoveryBridgeTopology ndbtB = new org . opennms . netmgt . enlinkd . service . api . DiscoveryBridgeTopology ( domain ) ; ndbtB . addUpdatedBFT ( topology . vrendmunalv02Id , topology . bftvrendmunalv02 ) ; ndbtB . addUpdatedBFT ( topology . vrendmunasw01Id , topology . bftvrendmunasw01 ) ; ndbtB . addUpdatedBFT ( topology . comunevillarendenawl1Id , topology . bftcomunevillarendenawl1 ) ; ndbtB . calculate ( ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( 0 , ndbtB . getFailed ( ) . size ( ) )", "method_name": "getFailed", "test_name": "testTwentySwitchTopologyVRendMun"}
{"focal_method": "controleer ( nl . bzk . migratiebrp . synchronisatie . dal . domein . brp . kern . entity . Persoon , nl . bzk . migratiebrp . bericht . model . sync . impl . VerwerkToevalligeGebeurtenisVerzoekBericht ) { final nl . bzk . migratiebrp . bericht . model . sync . generated . PersoonType persoon = verzoek . getPersoon ( ) ; if ( persoon == null ) { return false ; } return rootPersoon . getPersoonOverlijdenHistorieSet ( ) . isEmpty ( ) ; }", "test_method": "testFalseVerkeerdeVoorvoegsel ( ) { org . mockito . Mockito . when ( persoon . getVoornamen ( ) ) . thenReturn ( nl . bzk . migratiebrp . synchronisatie . runtime . service . toevalligegebeurtenis . controle . persoon . GeslachtsnaamComponentenControleTest . VOORNAMEN ) ; org . mockito . Mockito . when ( persoon . getVoorvoegsel ( ) ) . thenReturn ( nl . bzk . migratiebrp . synchronisatie . runtime . service . toevalligegebeurtenis . controle . persoon . GeslachtsnaamComponentenControleTest . VOORVOEGSELS ) ; org . mockito . Mockito . when ( persoon . getGeslachtsnaamstam ( ) ) . thenReturn ( nl . bzk . migratiebrp . synchronisatie . runtime . service . toevalligegebeurtenis . controle . persoon . GeslachtsnaamComponentenControleTest . GESLACHTSNAAM ) ; org . mockito . Mockito . when ( persoon . getAdellijkeTitel ( ) ) . thenReturn ( nl . bzk . migratiebrp . synchronisatie . runtime . service . toevalligegebeurtenis . controle . persoon . GeslachtsnaamComponentenControleTest . ADELLIJKTITEL ) ; org . mockito . Mockito . when ( persoon . getPredicaat ( ) ) . thenReturn ( nl . bzk . migratiebrp . synchronisatie . runtime . service . toevalligegebeurtenis . controle . persoon . GeslachtsnaamComponentenControleTest . PREDICAAT ) ; final nl . bzk . migratiebrp . bericht . model . sync . impl . VerwerkToevalligeGebeurtenisVerzoekBericht verzoek = new nl . bzk . migratiebrp . bericht . model . sync . impl . VerwerkToevalligeGebeurtenisVerzoekBericht ( ) ; final nl . bzk . migratiebrp . bericht . model . sync . generated . NaamGroepType naamGroepType = new nl . bzk . migratiebrp . bericht . model . sync . generated . NaamGroepType ( ) ; naamGroepType . setVoornamen ( nl . bzk . migratiebrp . synchronisatie . runtime . service . toevalligegebeurtenis . controle . persoon . GeslachtsnaamComponentenControleTest . VOORNAMEN ) ; naamGroepType . setVoorvoegsel ( \"den\" ) ; naamGroepType . setGeslachtsnaam ( nl . bzk . migratiebrp . synchronisatie . runtime . service . toevalligegebeurtenis . controle . persoon . GeslachtsnaamComponentenControleTest . GESLACHTSNAAM ) ; naamGroepType . setAdellijkeTitelPredicaat ( AdellijkeTitelPredicaatType . JH ) ; final nl . bzk . migratiebrp . bericht . model . sync . generated . PersoonType persoonType = new nl . bzk . migratiebrp . bericht . model . sync . generated . PersoonType ( ) ; persoonType . setNaam ( naamGroepType ) ; verzoek . setPersoon ( persoonType ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertFalse ( subject . controleer ( persoon , verzoek ) )", "method_name": "controleer", "test_name": "testFalseVerkeerdeVoorvoegsel"}
{"focal_method": "findAll ( com . gentics . mesh . core . data . MeshAuthUser , java . util . List , com . gentics . mesh . parameter . PagingParameters ) { com . syncleus . ferma . traversals . VertexTraversal < ? , ? , ? > traversal = user . getPermTraversal ( com . gentics . mesh . core . data . root . impl . READ_PERM ) ; return new com . gentics . mesh . core . data . page . impl . DynamicTransformablePageImpl < com . gentics . mesh . core . data . node . Node > ( user , traversal , pagingInfo , READ_PERM , com . gentics . mesh . core . data . node . impl . NodeImpl . class ) ; }", "test_method": "testFindAllVisible ( ) { try ( com . syncleus . ferma . tx . Tx tx = tx ( ) ) { com . gentics . mesh . core . data . page . Page < ? extends com . gentics . mesh . core . data . schema . SchemaContainer > page = meshRoot ( ) . getSchemaContainerRoot ( ) . findAll ( mockActionContext ( ) , new com . gentics . mesh . parameter . impl . PagingParametersImpl ( 1 , 25L ) ) ; \"<AssertPlaceHolder>\" ; } }", "assertion": "org . junit . Assert . assertNotNull ( page )", "method_name": "findAll", "test_name": "testFindAllVisible"}
{"focal_method": "equals ( java . lang . Object ) { if ( ( this ) == o ) return true ; if ( ( o == null ) || ( ( getClass ( ) ) != ( o . getClass ( ) ) ) ) return false ; org . apache . hadoop . yarn . service . component . instance . ComponentInstanceId that = ( ( org . apache . hadoop . yarn . service . component . instance . ComponentInstanceId ) ( o ) ) ; if ( ( getId ( ) ) != ( that . getId ( ) ) ) return false ; return ( getCompName ( ) ) != null ? getCompName ( ) . equals ( that . getCompName ( ) ) : ( that . getCompName ( ) ) == null ; }", "test_method": "testTwoByteTextFil ( ) { byte [ ] twoByteContents = new byte [ ] { 'x' , 'y' } ; java . lang . String output = readUsingTextCommand ( org . apache . hadoop . fs . shell . TestTextCommand . TEXT_FILENAME , twoByteContents ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertTrue ( new java . lang . String ( twoByteContents ) . equals ( output ) )", "method_name": "equals", "test_name": "testTwoByteTextFil"}
{"focal_method": "formatWithServerTimeZone ( java . util . Date ) { return org . kie . workbench . common . widgets . client . util . TimeZoneUtils . FORMATTER . format ( date , org . kie . workbench . common . widgets . client . util . TimeZoneUtils . getTimeZone ( ) ) ; }", "test_method": "testFormatWithServerTimeZone ( ) { final java . util . Date date = mock ( java . util . Date . class ) ; final com . google . gwt . i18n . client . TimeZone timeZone = mock ( com . google . gwt . i18n . client . TimeZone . class ) ; final java . lang . String expectedFormat = \"01-01-1900\" ; mockStatic ( org . kie . workbench . common . widgets . client . util . TimeZoneUtils . class ) ; when ( org . kie . workbench . common . widgets . client . util . TimeZoneUtils . getTimeZone ( ) ) . thenReturn ( timeZone ) ; when ( org . kie . workbench . common . widgets . client . util . TimeZoneUtils . formatWithServerTimeZone ( any ( java . util . Date . class ) ) ) . thenCallRealMethod ( ) ; when ( dateTimeFormat . format ( eq ( date ) , eq ( timeZone ) ) ) . thenReturn ( expectedFormat ) ; final java . lang . String actualFormat = org . kie . workbench . common . widgets . client . util . TimeZoneUtils . formatWithServerTimeZone ( date ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( expectedFormat , actualFormat )", "method_name": "formatWithServerTimeZone", "test_name": "testFormatWithServerTimeZone"}
{"focal_method": "toString ( ) { return ( ( getActionMemento ( ) . getNameParmsId ( ) ) + \"#\" ) + ( getNumber ( ) ) ; }", "test_method": "testConcatEmptyStringLeavesBufferUnchanged ( ) { t1 . concat ( \"\" ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( name , t1 . toString ( ) )", "method_name": "toString", "test_name": "testConcatEmptyStringLeavesBufferUnchanged"}
{"focal_method": "containsRowWithKey ( java . lang . Object [ ] ) { java . lang . String query = null ; boolean contains = false ; if ( ( delegate ) != null ) { if ( ( delegate ) instanceof com . vaadin . v7 . data . util . sqlcontainer . query . FreeformStatementDelegate ) { try { com . vaadin . v7 . data . util . sqlcontainer . query . generator . StatementHelper sh = ( ( com . vaadin . v7 . data . util . sqlcontainer . query . FreeformStatementDelegate ) ( delegate ) ) . getContainsRowQueryStatement ( keys ) ; java . sql . PreparedStatement pstmt = null ; java . sql . ResultSet rs = null ; java . sql . Connection c = getConnection ( ) ; try { pstmt = c . prepareStatement ( sh . getQueryString ( ) ) ; sh . setParameterValuesToStatement ( pstmt ) ; rs = pstmt . executeQuery ( ) ; contains = rs . next ( ) ; return contains ; } finally { releaseConnection ( c , pstmt , rs ) ; } } catch ( java . lang . UnsupportedOperationException e ) { } } try { query = delegate . getContainsRowQueryString ( keys ) ; } catch ( java . lang . UnsupportedOperationException e ) { query = modifyWhereClause ( keys ) ; } } else { query = modifyWhereClause ( keys ) ; } java . sql . Statement statement = null ; java . sql . ResultSet rs = null ; java . sql . Connection conn = getConnection ( ) ; try { statement = conn . createStatement ( ) ; rs = statement . executeQuery ( query ) ; contains = rs . next ( ) ; } finally { releaseConnection ( conn , statement , rs ) ; } return contains ; }", "test_method": "containsRowWithKeys_existingKeys_returnsTrue ( ) { com . vaadin . v7 . data . util . sqlcontainer . query . TableQuery tQuery = new com . vaadin . v7 . data . util . sqlcontainer . query . TableQuery ( \"people\" , connectionPool , com . vaadin . v7 . data . util . sqlcontainer . SQLTestsConstants . sqlGen ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertTrue ( tQuery . containsRowWithKey ( 1 ) )", "method_name": "containsRowWithKey", "test_name": "containsRowWithKeys_existingKeys_returnsTrue"}
{"focal_method": "getObject ( com . sun . sgs . service . Transaction , long , boolean ) { byte [ ] result = dataStore . getObject ( txn , oid , forUpdate ) ; com . sun . sgs . profile . ProfileOperation op = ( forUpdate ) ? stats . getObjectForUpdateOp : stats . getObjectOp ; op . report ( ) ; stats . readBytesCounter . incrementCount ( result . length ) ; stats . readObjectsCounter . incrementCount ( ) ; stats . readBytesSample . addSample ( result . length ) ; return result ; }", "test_method": "testSetObjectsEmptyData ( ) { long [ ] ids = new long [ ] { id } ; byte [ ] [ ] dataArray = new byte [ ] [ ] { new byte [ ] { } } ; com . sun . sgs . test . impl . service . data . store . TestDataStoreImpl . store . setObjects ( txn , ids , dataArray ) ; txn . commit ( ) ; txn = createTransaction ( UsePrepareAndCommit . ARBITRARY ) ; byte [ ] result = com . sun . sgs . test . impl . service . data . store . TestDataStoreImpl . store . getObject ( txn , id , false ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertTrue ( ( ( result . length ) == 0 ) )", "method_name": "getObject", "test_name": "testSetObjectsEmptyData"}
{"focal_method": "setUpExperiment ( java . lang . String [ ] ) { org . eclipse . tracecompass . tmf . core . trace . ITmfTrace [ ] traces = new org . eclipse . tracecompass . tmf . core . trace . ITmfTrace [ traceFiles . length ] ; int i = 0 ; for ( java . lang . String traceFile : traceFiles ) { org . eclipse . tracecompass . analysis . os . linux . core . tests . stubs . trace . TmfXmlKernelTraceStub trace = new org . eclipse . tracecompass . analysis . os . linux . core . tests . stubs . trace . TmfXmlKernelTraceStub ( ) ; org . eclipse . core . runtime . IPath filePath = org . eclipse . tracecompass . lttng2 . kernel . core . tests . Activator . getAbsoluteFilePath ( traceFile ) ; org . eclipse . core . runtime . IStatus status = trace . validate ( null , filePath . toOSString ( ) ) ; if ( ! ( status . isOK ( ) ) ) { org . junit . Assert . fail ( status . getException ( ) . getMessage ( ) ) ; } trace . initTrace ( null , filePath . toOSString ( ) , org . eclipse . tracecompass . tmf . core . event . ITmfEvent . class ) ; traces [ ( i ++ ) ] = trace ; } org . eclipse . tracecompass . tmf . core . trace . experiment . TmfExperiment experiment = new org . eclipse . tracecompass . tmf . core . trace . experiment . TmfExperiment ( org . eclipse . tracecompass . tmf . core . event . ITmfEvent . class , org . eclipse . tracecompass . lttng2 . kernel . core . tests . analysis . graph . DistributedCriticalPathTest . EXPERIMENT , traces , org . eclipse . tracecompass . lttng2 . kernel . core . tests . analysis . graph . DistributedCriticalPathTest . BLOCK_SIZE , null ) ; experiment . traceOpened ( new org . eclipse . tracecompass . tmf . core . signal . TmfTraceOpenedSignal ( this , experiment , null ) ) ; org . eclipse . tracecompass . tmf . core . analysis . IAnalysisModule module = null ; for ( org . eclipse . tracecompass . tmf . core . analysis . IAnalysisModule mod : org . eclipse . tracecompass . tmf . core . trace . TmfTraceUtils . getAnalysisModulesOfClass ( experiment , org . eclipse . tracecompass . analysis . graph . core . building . TmfGraphBuilderModule . class ) ) { module = mod ; } org . junit . Assert . assertNotNull ( module ) ; module . schedule ( ) ; org . junit . Assert . assertTrue ( module . waitForCompletion ( ) ) ; return experiment ; }", "test_method": "testNetworkExchangeOneTrace ( ) { org . eclipse . tracecompass . tmf . core . trace . ITmfTrace experiment = setUpExperiment ( \"testfiles/graph/network_exchange_wifi.xml\" ) ; \"<AssertPlaceHolder>\" ; try { org . eclipse . tracecompass . lttng2 . kernel . core . tests . analysis . graph . DistributedCriticalPathTest . internalTestNetworkExchangeOneTrace ( experiment ) ; } finally { experiment . dispose ( ) ; } }", "assertion": "org . junit . Assert . assertNotNull ( experiment )", "method_name": "setUpExperiment", "test_name": "testNetworkExchangeOneTrace"}
{"focal_method": "getSecond ( ) { return value ; }", "test_method": "testMaxPoolBackprop ( ) { org . nd4j . linalg . factory . Nd4j . getRandom ( ) . setSeed ( 12345 ) ; for ( int i = 0 ; i < 5 ; i ++ ) { int [ ] inputShape = new int [ ] { 1 , 1 , 4 , 3 } ; int [ ] kernel = new int [ ] { 2 , 2 } ; int [ ] strides = new int [ ] { 1 , 1 } ; int [ ] pad = new int [ ] { 0 , 0 } ; int [ ] dilation = new int [ ] { 1 , 1 } ; boolean same = true ; java . lang . String fn = \"maxpool2d_bp\" ; int nIArgs = 11 ; int [ ] a = new int [ nIArgs ] ; a [ 0 ] = kernel [ 0 ] ; a [ 1 ] = kernel [ 1 ] ; a [ 2 ] = strides [ 0 ] ; a [ 3 ] = strides [ 1 ] ; a [ 4 ] = pad [ 0 ] ; a [ 5 ] = pad [ 1 ] ; a [ 6 ] = dilation [ 0 ] ; a [ 7 ] = dilation [ 1 ] ; a [ 8 ] = ( same ) ? 1 : 0 ; a [ 10 ] = 0 ; java . util . List < org . nd4j . linalg . primitives . Pair < org . nd4j . linalg . api . ndarray . INDArray , java . lang . String > > inputs = org . nd4j . linalg . checkutil . NDArrayCreationUtil . getAll4dTestArraysWithShape ( 12345 , inputShape ) ; for ( org . nd4j . linalg . primitives . Pair < org . nd4j . linalg . api . ndarray . INDArray , java . lang . String > pIn : inputs ) { org . nd4j . linalg . api . ndarray . INDArray input = pIn . getFirst ( ) ; int [ ] outShapeHW = org . nd4j . linalg . convolution . ConvolutionTestsC . getOutputSize ( input , kernel , strides , pad , same ) ; java . util . List < org . nd4j . linalg . primitives . Pair < org . nd4j . linalg . api . ndarray . INDArray , java . lang . String > > eps = org . nd4j . linalg . checkutil . NDArrayCreationUtil . getAll4dTestArraysWithShape ( 12345 , inputShape [ 0 ] , inputShape [ 1 ] , outShapeHW [ 0 ] , outShapeHW [ 1 ] ) ; for ( org . nd4j . linalg . primitives . Pair < org . nd4j . linalg . api . ndarray . INDArray , java . lang . String > pEps : eps ) { org . nd4j . linalg . api . ndarray . INDArray epsilon = pEps . getFirst ( ) ; org . nd4j . linalg . api . ndarray . INDArray epsNext = org . nd4j . linalg . factory . Nd4j . create ( inputShape , 'c' ) ; epsilon = epsilon . dup ( 'c' ) ; org . nd4j . linalg . api . ops . DynamicCustomOp op = org . nd4j . linalg . api . ops . DynamicCustomOp . builder ( fn ) . addInputs ( input , epsilon ) . addOutputs ( epsNext ) . addIntegerArguments ( a ) . build ( ) ; org . nd4j . linalg . factory . Nd4j . getExecutioner ( ) . exec ( op ) ; org . nd4j . linalg . api . ndarray . INDArray expEpsNext = org . nd4j . linalg . convolution . ConvolutionTestsC . expGradMaxPoolBackPropSame ( input , epsilon , kernel , strides , same ) ; java . lang . String msg = ( ( \"input=\" + ( pIn . getSecond ( ) ) ) + \",<sp>eps=\" ) + ( pEps . getSecond ( ) ) ; \"<AssertPlaceHolder>\" ; } } } }", "assertion": "org . junit . Assert . assertEquals ( msg , expEpsNext , epsNext )", "method_name": "getSecond", "test_name": "testMaxPoolBackprop"}
{"focal_method": "size ( ) { return store . size ( ) ; }", "test_method": "testDecodeWithLeadingLFAndXmlDecl ( ) { final java . util . ArrayList < java . lang . Object > out = new java . util . ArrayList ( ) ; new org . opendaylight . netconf . nettyutil . handler . NetconfXMLToMessageDecoder ( ) . decode ( null , io . netty . buffer . Unpooled . wrappedBuffer ( \"\\n<?xml<sp>version=\\\"1.0\\\"<sp>encoding=\\\"UTF-8\\\"?><msg/>\" . getBytes ( ) ) , out ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( 1 , out . size ( ) )", "method_name": "size", "test_name": "testDecodeWithLeadingLFAndXmlDecl"}
{"focal_method": "makeScheduledPayments ( org . mifos . accounts . business . AccountPaymentEntity , java . util . List , org . mifos . customers . business . CustomerBO , org . mifos . accounts . productdefinition . util . helpers . SavingsType , org . mifos . framework . util . helpers . Money ) { org . mifos . application . master . business . MifosCurrency currency = payment . getAccount ( ) . getCurrency ( ) ; org . mifos . framework . util . helpers . Money amountRemaining = new org . mifos . framework . util . helpers . Money ( currency , payment . getAmount ( ) . getAmount ( ) ) ; org . mifos . framework . util . helpers . Money runningBalance = new org . mifos . framework . util . helpers . Money ( currency , savingsBalanceBeforeDeposit . getAmount ( ) ) ; final java . util . Date transactionDate = payment . getPaymentDate ( ) ; org . mifos . framework . util . helpers . Money depositAmount ; org . mifos . accounts . util . helpers . PaymentStatus paymentStatus ; if ( savingsType . getValue ( ) . equals ( SavingsType . VOLUNTARY . getValue ( ) ) ) { paymentStatus = org . mifos . accounts . util . helpers . PaymentStatus . PAID ; org . mifos . accounts . savings . business . SavingsScheduleEntity lastExpectedPayment = null ; for ( org . mifos . accounts . savings . business . SavingsScheduleEntity expectedPayment : scheduledDeposits ) { lastExpectedPayment = expectedPayment ; expectedPayment . setPaymentDetails ( new org . mifos . framework . util . helpers . Money ( currency ) , paymentStatus , new java . sql . Date ( transactionDate . getTime ( ) ) ) ; } if ( lastExpectedPayment != null ) { if ( amountRemaining . isGreaterThanOrEqual ( lastExpectedPayment . getTotalDepositDue ( ) ) ) { depositAmount = lastExpectedPayment . getTotalDepositDue ( ) ; amountRemaining = amountRemaining . subtract ( lastExpectedPayment . getTotalDepositDue ( ) ) ; } else { depositAmount = new org . mifos . framework . util . helpers . Money ( currency , amountRemaining . getAmount ( ) ) ; amountRemaining = new org . mifos . framework . util . helpers . Money ( currency ) ; } lastExpectedPayment . setPaymentDetails ( depositAmount , paymentStatus , new java . sql . Date ( transactionDate . getTime ( ) ) ) ; runningBalance = runningBalance . add ( depositAmount ) ; final org . mifos . accounts . savings . business . SavingsTrxnDetailEntity voluntaryPaymentTrxn = savingsTransactionActivityHelper . createSavingsTrxnForDeposit ( payment , depositAmount , payingCustomer , lastExpectedPayment , runningBalance ) ; payment . addAccountTrxn ( voluntaryPaymentTrxn ) ; } } else { for ( org . mifos . accounts . savings . business . SavingsScheduleEntity accountAction : scheduledDeposits ) { paymentStatus = org . mifos . accounts . util . helpers . PaymentStatus . UNPAID ; if ( amountRemaining . isGreaterThanOrEqual ( accountAction . getTotalDepositDue ( ) ) ) { depositAmount = accountAction . getTotalDepositDue ( ) ; amountRemaining = amountRemaining . subtract ( accountAction . getTotalDepositDue ( ) ) ; paymentStatus = org . mifos . accounts . util . helpers . PaymentStatus . PAID ; } else { depositAmount = new org . mifos . framework . util . helpers . Money ( currency , amountRemaining . getAmount ( ) ) ; amountRemaining = new org . mifos . framework . util . helpers . Money ( currency ) ; } accountAction . setPaymentDetails ( depositAmount , paymentStatus , new java . sql . Date ( transactionDate . getTime ( ) ) ) ; runningBalance = runningBalance . add ( depositAmount ) ; final org . mifos . accounts . savings . business . SavingsTrxnDetailEntity mandatoryScheduledPaymentTrxn = savingsTransactionActivityHelper . createSavingsTrxnForDeposit ( payment , depositAmount , payingCustomer , accountAction , runningBalance ) ; payment . addAccountTrxn ( mandatoryScheduledPaymentTrxn ) ; if ( amountRemaining . isLessThanOrEqualZero ( ) ) { return amountRemaining ; } } } return amountRemaining ; }", "test_method": "whenNoUnpaidScheduledInstallmentsExistTheFullAmountOfTheDepositIsReturned ( ) { final org . mifos . framework . util . helpers . Money balanceBeforeDeposit = new org . mifos . framework . util . helpers . Money ( org . mifos . framework . TestUtils . RUPEE , \"0.0\" ) ; final org . mifos . framework . util . helpers . Money fullDepositAmount = new org . mifos . framework . util . helpers . Money ( org . mifos . framework . TestUtils . RUPEE , \"100.0\" ) ; final java . util . Date dateOfDeposit = new org . joda . time . DateTime ( ) . toDate ( ) ; final java . util . List < org . mifos . accounts . savings . business . SavingsScheduleEntity > unpaidDepositsForPayingCustomer = java . util . Arrays . asList ( ) ; when ( accountPayment . getAmount ( ) ) . thenReturn ( fullDepositAmount ) ; when ( accountPayment . getPaymentDate ( ) ) . thenReturn ( dateOfDeposit ) ; final org . mifos . framework . util . helpers . Money remainingAmount = paymentStrategy . makeScheduledPayments ( accountPayment , unpaidDepositsForPayingCustomer , payingCustomer , SavingsType . MANDATORY , balanceBeforeDeposit ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertThat ( remainingAmount , org . hamcrest . CoreMatchers . is ( fullDepositAmount ) )", "method_name": "makeScheduledPayments", "test_name": "whenNoUnpaidScheduledInstallmentsExistTheFullAmountOfTheDepositIsReturned"}
{"focal_method": "getLabelID ( java . lang . String ) { addLabel ( label ) ; return labelMap . indexOf ( label ) ; }", "test_method": "testGetLabelID ( ) { java . lang . String label = \"R3\" ; org . openscience . cdk . smsd . helper . LabelContainer instance = new org . openscience . cdk . smsd . helper . LabelContainer ( ) ; instance . addLabel ( label ) ; java . lang . Integer expectedValue = 2 ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( expectedValue , instance . getLabelID ( \"R3\" ) )", "method_name": "getLabelID", "test_name": "testGetLabelID"}
{"focal_method": "hasWorkItems ( ) { return ( view . workItemsCount ( ) ) > 1 ; }", "test_method": "testHasWorkItemsWhenItIsTrue ( ) { when ( view . workItemsCount ( ) ) . thenReturn ( 2 ) ; final boolean hasWorkItems = page . hasWorkItems ( ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertTrue ( hasWorkItems )", "method_name": "hasWorkItems", "test_name": "testHasWorkItemsWhenItIsTrue"}
{"focal_method": "areDependencyTypesDetected ( java . lang . String , java . lang . String , java . util . ArrayList , boolean ) { return areDependencyTypesDetected ( classFrom , classTo , dependencyTypes , \"\" , isIndirect ) ; }", "test_method": "CallInstanceMethodIndirect_VarMethod ( ) { java . lang . String fromClass = \"domain.indirect.violatingfrom.CallInstanceMethodIndirect_VarMethod\" ; java . lang . String toClass = \"domain.indirect.indirectto.ServiceOne\" ; java . util . ArrayList < java . lang . String > typesToFind = new java . util . ArrayList < java . lang . String > ( ) ; typesToFind . add ( \"Call\" ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertTrue ( areDependencyTypesDetected ( fromClass , toClass , typesToFind , true ) )", "method_name": "areDependencyTypesDetected", "test_name": "CallInstanceMethodIndirect_VarMethod"}
{"focal_method": "logoutUser ( javax . servlet . http . HttpSession ) { org . oscm . integrationhelper . BssClient . logger . debug ( ( \"logoutUser<sp>-<sp>\" + ( session . getId ( ) ) ) ) ; if ( ( ( session . getAttribute ( Constants . SUB_KEY ) ) == null ) || ( ( session . getAttribute ( Constants . CM_ID ) ) == null ) ) { org . oscm . integrationhelper . BssClient . logger . error ( \"logoutUser<sp>-<sp>subKey<sp>or<sp>bssId<sp>missing!\" ) ; return null ; } return org . oscm . integrationhelper . BssClient . deleteServiceSession ( java . lang . Long . parseLong ( session . getAttribute ( Constants . SUB_KEY ) . toString ( ) ) , session . getAttribute ( Constants . CM_ID ) . toString ( ) ) ; }", "test_method": "logoutUser_bssidNull ( ) { javax . servlet . http . HttpSession session = mock ( javax . servlet . http . HttpSession . class ) ; doReturn ( \"subid\" ) . when ( session ) . getAttribute ( eq ( Constants . SUB_KEY ) ) ; doReturn ( null ) . when ( session ) . getAttribute ( Constants . CM_ID ) ; java . lang . String string = org . oscm . integrationhelper . BssClient . logoutUser ( session ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertNull ( string )", "method_name": "logoutUser", "test_name": "logoutUser_bssidNull"}
{"focal_method": "length ( ) { return nextFencePost ; }", "test_method": "testCompressorTooLongMethod ( ) { eu . numberfour . n4js . antlr . compressor . ParserCompressorFragment2 pci = new eu . numberfour . n4js . antlr . compressor . ParserCompressorFragment2 ( ) ; java . lang . String tokenValues = loadFile ( \"TokenValues.txt\" ) ; java . util . Map < java . lang . String , java . lang . Integer > constMap = pci . createConstMap ( tokenValues ) ; java . lang . String javaContent = loadFile ( \"TooLongMethodSnippet1.txt\" ) ; java . lang . String result = pci . processCascades ( javaContent , constMap ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertTrue ( ( ( result . length ( ) ) < ( javaContent . length ( ) ) ) )", "method_name": "length", "test_name": "testCompressorTooLongMethod"}
{"focal_method": "getLogManager ( ) { return logManager ; }", "test_method": "testLogManagerCreation ( ) { org . jsoar . kernel . LogManager logManager = agent . getLogManager ( ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertNotNull ( logManager )", "method_name": "getLogManager", "test_name": "testLogManagerCreation"}
{"focal_method": "getCapturedEvents ( ) { return capturedEvents ; }", "test_method": "testBuildReportChunkSuccessfull2 ( ) { imagedata . setCaption ( null ) ; instance . buildReportChunk ( ichunk , doc , true ) ; java . util . ArrayList < java . lang . Object [ ] > events = docListener . getCapturedEvents ( ) ; \"<AssertPlaceHolder>\" ; java . lang . Object [ ] event = events . get ( 0 ) ; confirmParagraphAdded ( event , \"CONTEXT:<sp>ERROR\" ) ; event = events . get ( 1 ) ; confirmParagraphAdded ( event , ( \"GROUP:<sp>\" + ( group ) ) ) ; event = events . get ( 2 ) ; confirmParagraphAdded ( event , ( \"RULE:<sp>\" + ( rule ) ) ) ; event = events . get ( 3 ) ; confirmParagraphAdded ( event , \"TAGS:<sp>'tag1'<sp>'tag2'\" ) ; event = events . get ( 4 ) ; confirmImageAdded ( event , imagedata . getURL ( ) ) ; }", "assertion": "org . junit . Assert . assertTrue ( ( ( events . size ( ) ) == 5 ) )", "method_name": "getCapturedEvents", "test_name": "testBuildReportChunkSuccessfull2"}
{"focal_method": "add ( T ) { return this . queue . offer ( data ) ; }", "test_method": "test_with_random_codes ( ) { final int numCodes = org . apache . commons . lang3 . RandomUtils . nextInt ( 1 , com . navercorp . pinpoint . common . server . bo . codec . stat . header . BitCountingHeaderEncoderTest . MAX_NUM_TEST_VALUES ) ; final java . util . List < java . lang . Integer > givenCodes = new java . util . ArrayList < java . lang . Integer > ( numCodes ) ; for ( int i = 0 ; i < numCodes ; i ++ ) { givenCodes . add ( com . navercorp . pinpoint . common . server . bo . codec . stat . header . BitCountingHeaderEncoderTest . RANDOM . nextInt ( 5 ) ) ; } com . navercorp . pinpoint . common . server . bo . codec . stat . header . BitCountingHeaderEncoder encoder = new com . navercorp . pinpoint . common . server . bo . codec . stat . header . BitCountingHeaderEncoder ( ) ; for ( int i = 0 ; i < ( givenCodes . size ( ) ) ; i ++ ) { encoder . addCode ( givenCodes . get ( i ) ) ; } final byte [ ] header = encoder . getHeader ( ) ; java . util . List < java . lang . Integer > decodedCodes = new java . util . ArrayList < java . lang . Integer > ( numCodes ) ; com . navercorp . pinpoint . common . server . bo . codec . stat . header . BitCountingHeaderDecoder decoder = new com . navercorp . pinpoint . common . server . bo . codec . stat . header . BitCountingHeaderDecoder ( header ) ; for ( int i = 0 ; i < numCodes ; i ++ ) { int code = decoder . getCode ( ) ; decodedCodes . add ( code ) ; } \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( givenCodes , decodedCodes )", "method_name": "add", "test_name": "test_with_random_codes"}
{"focal_method": "isEqualByComparingTo ( java . lang . String ) { return super . isEqualByComparingTo ( new java . math . BigDecimal ( expected ) ) ; }", "test_method": "should_return_this ( ) { org . fest . assertions . api . ConcreteUnevenComparableAssert returned = assertions . isEqualByComparingTo ( actual ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertSame ( assertions , returned )", "method_name": "isEqualByComparingTo", "test_name": "should_return_this"}
{"focal_method": "getMinimumChangeNumber ( ) { try { return jdbcTemplate . queryForObject ( org . sagebionetworks . repo . model . dbo . dao . DBOChangeDAOImpl . SQL_SELECT_MIN_CHANGE_NUMBER , org . sagebionetworks . repo . model . dbo . dao . Long . class ) ; } catch ( java . lang . NullPointerException e ) { return 0L ; } }", "test_method": "testGetMinimumChangeNumberEmpty ( ) { long mcn = changeDAO . getMinimumChangeNumber ( ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( 0L , mcn )", "method_name": "getMinimumChangeNumber", "test_name": "testGetMinimumChangeNumberEmpty"}
{"focal_method": "checksumCRC32 ( org . pentaho . di . core . row . ValueMetaInterface , java . lang . Object , boolean ) { long checksum = 0 ; if ( dataA == null ) { return checksum ; } org . apache . commons . vfs2 . FileObject file = null ; java . util . zip . CheckedInputStream cis = null ; try { file = org . pentaho . di . core . vfs . KettleVFS . getFileObject ( dataA . toString ( ) ) ; org . pentaho . di . core . row . ValueDataUtil . throwsErrorOnFileNotFound ( file ) ; cis = null ; cis = new java . util . zip . CheckedInputStream ( org . pentaho . di . core . vfs . KettleVFS . getInputStream ( file ) , new java . util . zip . CRC32 ( ) ) ; byte [ ] buf = new byte [ 128 ] ; int readSize = 0 ; do { readSize = cis . read ( buf ) ; } while ( readSize >= 0 ) ; checksum = cis . getChecksum ( ) . getValue ( ) ; } catch ( org . pentaho . di . core . exception . KettleFileNotFoundException e ) { if ( failIfNoFile ) { throw e ; } org . pentaho . di . core . row . ValueDataUtil . log . debug ( e . getMessage ( ) ) ; } catch ( java . lang . Exception e ) { org . pentaho . di . core . row . ValueDataUtil . log . debug ( e . getMessage ( ) ) ; } finally { org . apache . commons . io . IOUtils . closeQuietly ( file ) ; org . apache . commons . io . IOUtils . closeQuietly ( cis ) ; } return checksum ; }", "test_method": "checksumCRC32NullPathNoFailTest ( ) { long checksum = org . pentaho . di . core . row . ValueDataUtil . checksumCRC32 ( new org . pentaho . di . core . row . value . ValueMetaString ( ) , null , false ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( 0 , checksum )", "method_name": "checksumCRC32", "test_name": "checksumCRC32NullPathNoFailTest"}
{"focal_method": "isValidToExecute ( uk . gov . gchq . gaffer . user . User ) { return ( isPublic ) || ( ( null != user ) && ( ( isAddingUser ( user ) ) || ( ( ! ( isAuthsNullOrEmpty ( ) ) ) && ( isUserHasASharedAuth ( user ) ) ) ) ) ; }", "test_method": "shouldNeverValidateNullUserIV ( ) { final uk . gov . gchq . gaffer . federatedstore . FederatedAccess access = new uk . gov . gchq . gaffer . federatedstore . FederatedAccess . Builder ( ) . addingUserId ( null ) . build ( ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertFalse ( access . isValidToExecute ( null ) )", "method_name": "isValidToExecute", "test_name": "shouldNeverValidateNullUserIV"}
{"focal_method": "getXAttrName ( ) { return getValue ( ) ; }", "test_method": "testXAttrNameParam ( ) { final org . apache . hadoop . hdfs . web . resources . XAttrNameParam p = new org . apache . hadoop . hdfs . web . resources . XAttrNameParam ( \"user.a1\" ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( p . getXAttrName ( ) , \"user.a1\" )", "method_name": "getXAttrName", "test_name": "testXAttrNameParam"}
{"focal_method": "findWaitingListsAndDemographics ( java . lang . Integer ) { javax . persistence . Query query = entityManager . createQuery ( \"FROM<sp>WaitingList<sp>w,<sp>Demographic<sp>d<sp>WHERE<sp>w.demographicNo<sp>=<sp>d.DemographicNo<sp>AND<sp>w.listId<sp>=<sp>:listId<sp>AND<sp>w.isHistory<sp>=<sp>'N'<sp>ORDER<sp>BY<sp>w.position\" ) ; query . setParameter ( \"listId\" , listId ) ; return query . getResultList ( ) ; }", "test_method": "testFindWaitingListsAndDemographics ( ) { java . util . List < java . lang . Object [ ] > results = dao . findWaitingListsAndDemographics ( 1 ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertNotNull ( results )", "method_name": "findWaitingListsAndDemographics", "test_name": "testFindWaitingListsAndDemographics"}
{"focal_method": "pulseCount ( ) { return count ; }", "test_method": "countIs2AfterAdding2Pulses ( ) { pulseLengthAnalyzer . addPulse ( 10.0 , false ) ; pulseLengthAnalyzer . addPulse ( 10.0 , true ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertThat ( pulseLengthAnalyzer . pulseCount ( ) , org . hamcrest . core . Is . is ( 2 ) )", "method_name": "pulseCount", "test_name": "countIs2AfterAdding2Pulses"}
{"focal_method": "size ( ) { return this . cells . size ( ) ; }", "test_method": "RgroupSymbolY ( ) { org . openscience . cdk . renderer . generators . standard . AtomSymbol atomSymbol = atomGenerator . generatePseudoSymbol ( \"Y1a2\" , HydrogenPosition . Right ) ; java . util . List < java . awt . Shape > shapes = atomSymbol . getOutlines ( ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertThat ( shapes . size ( ) , org . hamcrest . CoreMatchers . is ( 1 ) )", "method_name": "size", "test_name": "RgroupSymbolY"}
{"focal_method": "apply ( T1 , T2 , T3 , T4 , T5 ) { return new com . m3 . scalaflavor4j . Tuple5 < T1 , T2 , T3 , T4 , T5 > ( _1 , _2 , _3 , _4 , _5 ) ; }", "test_method": "__A$VoidFunction1_emptyGenerator ( ) { com . m3 . scalaflavor4j . CollectionLike < java . lang . String > xs1 = com . m3 . scalaflavor4j . Seq . apply ( \"a\" , \"b\" ) ; com . m3 . scalaflavor4j . CollectionLike < java . lang . Integer > xs2 = com . m3 . scalaflavor4j . Seq . apply ( 1 , 2 , 3 , 4 , 5 ) ; com . m3 . scalaflavor4j . CollectionLike < java . lang . Long > xs3 = com . m3 . scalaflavor4j . Seq . apply ( ) ; final com . m3 . scalaflavor4j . ForComprehension3Test . Called c = new com . m3 . scalaflavor4j . ForComprehension3Test . Called ( ) ; com . m3 . scalaflavor4j . For . apply ( xs1 , xs2 , xs3 ) . apply ( new com . m3 . scalaflavor4j . VoidF1 < com . m3 . scalaflavor4j . Tuple3 < java . lang . String , java . lang . Integer , java . lang . Long > > ( ) { public void apply ( com . m3 . scalaflavor4j . Tuple3 < java . lang . String , java . lang . Integer , java . lang . Long > t ) { ( c . count ) ++ ; } } ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertThat ( c . count , org . hamcrest . CoreMatchers . is ( org . hamcrest . CoreMatchers . equalTo ( 0 ) ) )", "method_name": "apply", "test_name": "__A$VoidFunction1_emptyGenerator"}
{"focal_method": "connect ( org . jsoup . helper . URL ) { org . jsoup . helper . Connection con = new org . jsoup . helper . HttpConnection ( ) ; con . url ( url ) ; return con ; }", "test_method": "timeout ( ) { org . jsoup . Connection con = org . jsoup . helper . HttpConnection . connect ( \"http://example.com/\" ) ; con . timeout ( 1000 ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( 1000 , con . request ( ) . timeout ( ) )", "method_name": "connect", "test_name": "timeout"}
{"focal_method": "invoke ( javax . xml . transform . dom . DOMSource ) { java . lang . Thread . currentThread ( ) . setName ( \"Stuf<sp>bericht<sp>vertaler<sp>ontvanger\" ) ; nl . bzk . brp . delivery . stuf . StufWebService . LOGGER . debug ( \"Stuf<sp>bericht<sp>vertaler<sp>ontvanger<sp>aangeroepen\" ) ; nl . bzk . brp . domain . leveringmodel . persoon . BrpNu . set ( nl . bzk . algemeenbrp . util . common . DatumUtil . nuAlsZonedDateTime ( ) ) ; try { schemaValidatorService . valideer ( request , nl . bzk . brp . delivery . stuf . StufWebService . SCHEMA ) ; } catch ( nl . bzk . brp . service . algemeen . request . SchemaValidatorService schemaValidatieException ) { nl . bzk . brp . delivery . stuf . StufWebService . LOGGER . debug ( \"Stuf<sp>bericht<sp>vertaler<sp>ontvanger<sp>aangeroepen<sp>met<sp>invalide<sp>xml\" , schemaValidatieException ) ; throw new org . apache . cxf . interceptor . Fault ( schemaValidatieException . getCause ( ) ) ; } return nl . bzk . brp . service . algemeen . AlgemeneFoutHandler . doeBijFout ( ( e ) -> { nl . bzk . brp . delivery . stuf . StufWebService . LOGGER . error ( \"Algemene<sp>fout\" , e ) ; throw new javax . xml . ws . WebServiceException ( \"Er<sp>is<sp>iets<sp>fout<sp>gegaan<sp>bij<sp>het<sp>verwerken<sp>van<sp>het<sp>stuf<sp>vertaal<sp>verzoek.\" ) ; } ) . voerUit ( ( ) -> maakResponse ( request ) ) ; }", "test_method": "testIsBijhoudingActueel_Lo3Historie ( ) { onderzoek . setVoortgekomenUitNietActueelVoorkomen ( true ) ; nl . bzk . migratiebrp . synchronisatie . dal . service . impl . delta . proces . OnderzoekPaar paar = new nl . bzk . migratiebrp . synchronisatie . dal . service . impl . delta . proces . OnderzoekPaar ( onderzoek , null ) ; final java . lang . reflect . Method testMethod = nl . bzk . migratiebrp . synchronisatie . dal . service . impl . delta . proces . OnderzoekPaar . class . getDeclaredMethod ( \"isBijhoudingActueel\" ) ; testMethod . setAccessible ( true ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertFalse ( ( ( boolean ) ( testMethod . invoke ( paar ) ) ) )", "method_name": "invoke", "test_name": "testIsBijhoudingActueel_Lo3Historie"}
{"focal_method": "getDOMRESBY ( ) { return \"<-:\" ; }", "test_method": "testGetDOMRESBY ( ) { java . lang . String actual = table . getDOMRESBY ( ) ; java . lang . String expected = \"<-:\" ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( expected , actual )", "method_name": "getDOMRESBY", "test_name": "testGetDOMRESBY"}
{"focal_method": "createSnakeCase ( ) { return new com . google . gson . GsonBuilder ( ) . setFieldNamingPolicy ( FieldNamingPolicy . LOWER_CASE_WITH_UNDERSCORES ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . LayoutBlock . class , new com . github . seratch . jslack . common . json . GsonLayoutBlockFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . composition . TextObject . class , new com . github . seratch . jslack . common . json . GsonTextObjectFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . ContextBlockElement . class , new com . github . seratch . jslack . common . json . GsonContextBlockElementFactory ( ) ) . registerTypeAdapter ( com . github . seratch . jslack . api . model . block . element . BlockElement . class , new com . github . seratch . jslack . common . json . GsonBlockElementFactory ( ) ) . create ( ) ; }", "test_method": "serialize ( ) { com . google . gson . Gson gson = com . github . seratch . jslack . common . json . GsonFactory . createSnakeCase ( ) ; com . github . seratch . jslack . api . model . event . ChannelRenameEvent event = new com . github . seratch . jslack . api . model . event . ChannelRenameEvent ( ) ; event . setChannel ( new com . github . seratch . jslack . api . model . event . ChannelRenameEvent . Channel ( ) ) ; event . getChannel ( ) . setName ( \"foo\" ) ; java . lang . String generatedJson = gson . toJson ( event ) ; java . lang . String expectedJson = \"{\\\"type\\\":\\\"channel_rename\\\",\\\"channel\\\":{\\\"name\\\":\\\"foo\\\"}}\" ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertThat ( generatedJson , org . hamcrest . CoreMatchers . is ( expectedJson ) )", "method_name": "createSnakeCase", "test_name": "serialize"}
{"focal_method": "getAsString ( javax . faces . context . FacesContext , javax . faces . component . UIComponent , java . lang . Object ) { java . lang . String retVal ; if ( ! ( object instanceof org . oscm . internal . vo . VOPaymentInfo ) ) { retVal = \"\" ; } else { retVal = java . lang . String . valueOf ( ( ( org . oscm . internal . vo . VOPaymentInfo ) ( object ) ) . getKey ( ) ) ; } return retVal ; }", "test_method": "testGetAsStringOneChar ( ) { java . lang . String in = \"x\" ; java . lang . String out = converter . getAsString ( context , component , in ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( in , out )", "method_name": "getAsString", "test_name": "testGetAsStringOneChar"}
{"focal_method": "getTags ( ) { return tags ; }", "test_method": "testTaggedMetricsNull ( ) { final com . github . sps . metrics . Map < java . lang . String , java . lang . String > tags = null ; com . github . sps . metrics . TaggedGauge < java . lang . Integer > gauge = new com . github . sps . metrics . TaggedGauge < java . lang . Integer > ( ) { @ com . github . sps . metrics . Override public com . github . sps . metrics . Integer getValue ( ) { return 1 ; } @ com . github . sps . metrics . Override public com . github . sps . metrics . Map < java . lang . String , java . lang . String > getTags ( ) { return tags ; } } ; final com . github . sps . metrics . TaggedCounter counter = new com . github . sps . metrics . TaggedCounter ( tags ) ; final com . github . sps . metrics . TaggedHistogram histogram = mock ( com . github . sps . metrics . TaggedHistogram . class ) ; when ( histogram . getCount ( ) ) . thenReturn ( 1L ) ; when ( histogram . getTags ( ) ) . thenReturn ( tags ) ; final com . github . sps . metrics . Snapshot snapshot = mock ( com . github . sps . metrics . Snapshot . class ) ; when ( snapshot . getMax ( ) ) . thenReturn ( 2L ) ; when ( snapshot . getMean ( ) ) . thenReturn ( 3.0 ) ; when ( snapshot . getMin ( ) ) . thenReturn ( 4L ) ; when ( snapshot . getStdDev ( ) ) . thenReturn ( 5.0 ) ; when ( snapshot . getMedian ( ) ) . thenReturn ( 6.0 ) ; when ( snapshot . get75thPercentile ( ) ) . thenReturn ( 7.0 ) ; when ( snapshot . get95thPercentile ( ) ) . thenReturn ( 8.0 ) ; when ( snapshot . get98thPercentile ( ) ) . thenReturn ( 9.0 ) ; when ( snapshot . get99thPercentile ( ) ) . thenReturn ( 10.0 ) ; when ( snapshot . get999thPercentile ( ) ) . thenReturn ( 11.0 ) ; when ( histogram . getSnapshot ( ) ) . thenReturn ( snapshot ) ; final com . github . sps . metrics . TaggedMeter meter = new com . github . sps . metrics . TaggedMeter ( tags ) ; final com . github . sps . metrics . TaggedTimer timer = new com . github . sps . metrics . TaggedTimer ( tags ) ; com . github . sps . metrics . SortedMap < java . lang . String , com . github . sps . metrics . Gauge > gauges = new com . github . sps . metrics . TreeMap < java . lang . String , com . github . sps . metrics . Gauge > ( ) ; gauges . put ( \"gauge\" , gauge ) ; reporter . report ( gauges , this . < com . github . sps . metrics . Counter > map ( \"counter\" , counter ) , this . < com . github . sps . metrics . Histogram > map ( \"histogram\" , histogram ) , this . < com . github . sps . metrics . Meter > map ( \"meter\" , meter ) , this . < com . codahale . metrics . Timer > map ( \"timer\" , timer ) ) ; verify ( opentsdb ) . send ( captor . capture ( ) ) ; final com . github . sps . metrics . Set < com . github . sps . metrics . opentsdb . OpenTsdbMetric > metrics = captor . getValue ( ) ; final com . github . sps . metrics . Map < java . lang . String , java . lang . String > expectedTags = new com . github . sps . metrics . HashMap < java . lang . String , java . lang . String > ( ) ; expectedTags . put ( \"foo\" , \"bar\" ) ; for ( com . github . sps . metrics . opentsdb . OpenTsdbMetric metric : metrics ) { \"<AssertPlaceHolder>\" ; } }", "assertion": "org . junit . Assert . assertEquals ( expectedTags , metric . getTags ( ) )", "method_name": "getTags", "test_name": "testTaggedMetricsNull"}
{"focal_method": "isProjectDisabled ( fr . norad . visuwall . api . domain . SoftwareProjectId ) { checkConnected ( ) ; checkSoftwareProjectId ( softwareProjectId ) ; try { java . lang . String jobName = softwareProjectId . getProjectId ( ) ; fr . norad . visuwall . providers . hudson . domain . HudsonJob job = hudson . findJob ( jobName ) ; return job . isDisabled ( ) ; } catch ( fr . norad . visuwall . providers . hudson . exception . HudsonJobNotFoundException e ) { throw new fr . norad . visuwall . api . exception . ProjectNotFoundException ( ( \"Can't<sp>find<sp>job<sp>with<sp>software<sp>project<sp>id:<sp>\" + softwareProjectId ) , e ) ; } }", "test_method": "should_projects_are_not_disabled ( ) { boolean projectDisabled = connection . isProjectDisabled ( fr . norad . visuwall . plugin . demo . SoftwareProjectIds . earth ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertFalse ( projectDisabled )", "method_name": "isProjectDisabled", "test_name": "should_projects_are_not_disabled"}
{"focal_method": "call ( ) { return parseReactomeEntryPage ( this . pathwayId ) ; }", "test_method": "testGetCofactors ( ) { uk . ac . ebi . ep . adapter . intenz . IntenzCallable . GetCofactorsCaller cofactorsCaller = new uk . ac . ebi . ep . adapter . intenz . IntenzCallable . GetCofactorsCaller ( \"ftp://ftp.ebi.ac.uk/pub/databases/intenz/xml/ASCII/EC_1/EC_1.1/EC_1.1.1/EC_1.1.1.1.xml\" ) ; java . util . Collection < uk . ac . ebi . ep . enzyme . model . Molecule > cofactors = cofactorsCaller . call ( ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( 2 , cofactors . size ( ) )", "method_name": "call", "test_name": "testGetCofactors"}
{"focal_method": "equals ( java . lang . Object ) { if ( obj == ( this ) ) { return true ; } if ( ! ( obj instanceof org . jfree . data . general . TestIntervalCategoryDataset ) ) { return false ; } org . jfree . data . general . TestIntervalCategoryDataset that = ( ( org . jfree . data . general . TestIntervalCategoryDataset ) ( obj ) ) ; if ( ! ( getRowKeys ( ) . equals ( that . getRowKeys ( ) ) ) ) { return false ; } if ( ! ( getColumnKeys ( ) . equals ( that . getColumnKeys ( ) ) ) ) { return false ; } int rowCount = getRowCount ( ) ; int colCount = getColumnCount ( ) ; for ( int r = 0 ; r < rowCount ; r ++ ) { for ( int c = 0 ; c < colCount ; c ++ ) { java . lang . Number v1 = getValue ( r , c ) ; java . lang . Number v2 = that . getValue ( r , c ) ; if ( v1 == null ) { if ( v2 != null ) { return false ; } } else if ( ! ( v1 . equals ( v2 ) ) ) { return false ; } } } return true ; }", "test_method": "testEquals1481087 ( ) { org . jfree . chart . labels . StandardCategoryToolTipGenerator g1 = new org . jfree . chart . labels . StandardCategoryToolTipGenerator ( \"{0}\" , new java . text . DecimalFormat ( \"0.00\" ) ) ; org . jfree . chart . labels . StandardCategoryItemLabelGenerator g2 = new org . jfree . chart . labels . StandardCategoryItemLabelGenerator ( \"{0}\" , new java . text . DecimalFormat ( \"0.00\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertFalse ( g1 . equals ( g2 ) )", "method_name": "equals", "test_name": "testEquals1481087"}
{"focal_method": "matches ( javassist . CtField ) { javassist . CtClass declaringClass = ctField . getDeclaringClass ( ) ; java . lang . String className = declaringClass . getName ( ) ; if ( ! ( this . patternClass . matcher ( className ) . matches ( ) ) ) { return false ; } java . lang . String fieldName = ctField . getName ( ) ; return this . patternField . matcher ( fieldName ) . matches ( ) ; }", "test_method": "testConstructorOneParamLongUnsuccessful ( ) { japicmp . filter . JavadocLikeBehaviorFilter filter = new japicmp . filter . JavadocLikeBehaviorFilter ( \"japicmp.Test#Test(java.lang.Long)\" ) ; javassist . ClassPool classPool = new javassist . ClassPool ( ) ; classPool . appendSystemPath ( ) ; javassist . CtClass ctClass = japicmp . util . CtClassBuilder . create ( ) . name ( \"japicmp.Test\" ) . addToClassPool ( classPool ) ; javassist . CtConstructor ctConstructor = japicmp . util . CtConstructorBuilder . create ( ) . parameter ( classPool . get ( \"java.lang.Double\" ) ) . addToClass ( ctClass ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertThat ( filter . matches ( ctConstructor ) , org . hamcrest . core . Is . is ( false ) )", "method_name": "matches", "test_name": "testConstructorOneParamLongUnsuccessful"}
{"focal_method": "equals ( java . lang . Object ) { if ( ( this ) == obj ) return true ; if ( obj == null ) return false ; if ( ( getClass ( ) ) != ( obj . getClass ( ) ) ) return false ; org . numenta . nupic . Parameters other = ( ( org . numenta . nupic . Parameters ) ( obj ) ) ; if ( ( paramMap ) == null ) { if ( ( other . paramMap ) != null ) return false ; } else { java . lang . Class < ? > [ ] classArray = new java . lang . Class [ ] { java . lang . Object . class } ; try { for ( org . numenta . nupic . Parameters . KEY key : paramMap . keySet ( ) ) { if ( ( ( paramMap . get ( key ) ) == null ) || ( ( other . paramMap . get ( key ) ) == null ) ) continue ; java . lang . Class < ? > thisValueClass = paramMap . get ( key ) . getClass ( ) ; java . lang . Class < ? > otherValueClass = other . paramMap . get ( key ) . getClass ( ) ; boolean isSpecial = isSpecial ( key , thisValueClass ) ; if ( ( ! isSpecial ) && ( ( ( thisValueClass . getMethod ( \"equals\" , classArray ) . getDeclaringClass ( ) ) != thisValueClass ) || ( ( otherValueClass . getMethod ( \"equals\" , classArray ) . getDeclaringClass ( ) ) != otherValueClass ) ) ) { continue ; } else if ( isSpecial ) { if ( int [ ] . class . isAssignableFrom ( thisValueClass ) ) { if ( ! ( java . util . Arrays . equals ( ( ( int [ ] ) ( paramMap . get ( key ) ) ) , ( ( int [ ] ) ( other . paramMap . get ( key ) ) ) ) ) ) return false ; } else if ( key == ( org . numenta . nupic . Parameters . KEY . FIELD_ENCODING_MAP ) ) { if ( ! ( com . cedarsoftware . util . DeepEquals . deepEquals ( paramMap . get ( key ) , other . paramMap . get ( key ) ) ) ) { return false ; } } } else if ( ( ! ( other . paramMap . containsKey ( key ) ) ) || ( ! ( paramMap . get ( key ) . equals ( other . paramMap . get ( key ) ) ) ) ) { return false ; } } } catch ( java . lang . Exception e ) { return false ; } } return true ; }", "test_method": "testAsCellIndexes ( ) { org . numenta . nupic . model . Connections cn = new org . numenta . nupic . model . Connections ( ) ; cn . setColumnDimensions ( new int [ ] { 64 , 64 } ) ; cn . setCellsPerColumn ( 4 ) ; org . numenta . nupic . algorithms . TemporalMemory . init ( cn ) ; int [ ] expectedIndexes = new int [ ] { 0 , 3 , 4 , 16383 } ; java . util . Set < org . numenta . nupic . model . Cell > cells = cn . getCellSet ( expectedIndexes ) ; java . util . List < java . lang . Integer > cellIdxList = org . numenta . nupic . model . Connections . asCellIndexes ( cells ) ; java . util . Set < java . lang . Integer > cellIdxSet = new java . util . HashSet ( cellIdxList ) ; java . util . Set < java . lang . Integer > expectedIdxSet = new java . util . HashSet < java . lang . Integer > ( java . util . stream . IntStream . of ( expectedIndexes ) . boxed ( ) . collect ( java . util . stream . Collectors . toList ( ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertTrue ( cellIdxSet . equals ( expectedIdxSet ) )", "method_name": "equals", "test_name": "testAsCellIndexes"}
{"focal_method": "getSubject ( ) { return configurable ; }", "test_method": "testCreateDataflowInputPortEdit ( ) { org . apache . taverna . workflowmodel . Edit < org . apache . taverna . workflowmodel . Dataflow > edit = org . apache . taverna . workflowmodel . impl . CreateDataflowInputPortEditTest . edits . getCreateDataflowInputPortEdit ( dataflow , portName , portDepth , portGranularDepth ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( dataflow , edit . getSubject ( ) )", "method_name": "getSubject", "test_name": "testCreateDataflowInputPortEdit"}
{"focal_method": "stripLeadingPeriod ( java . lang . String ) { if ( path . startsWith ( io . fabric8 . maven . docker . util . PathTestUtil . DOT ) ) { return path . substring ( 1 ) ; } return path ; }", "test_method": "testResolveParentRelativeVolumePath ( ) { java . lang . String relativePath = ( io . fabric8 . maven . docker . util . PathTestUtil . DOT ) + ( io . fabric8 . maven . docker . util . VolumeBindingUtilTest . RELATIVE_PATH ) ; java . lang . String volumeString = java . lang . String . format ( BIND_STRING_FMT , relativePath , io . fabric8 . maven . docker . util . VolumeBindingUtilTest . CONTAINER_PATH ) ; java . lang . String relativizedVolumeString = io . fabric8 . maven . docker . util . VolumeBindingUtil . resolveRelativeVolumeBinding ( io . fabric8 . maven . docker . util . VolumeBindingUtilTest . ABS_BASEDIR , volumeString ) ; java . lang . String expectedBindingString = java . lang . String . format ( BIND_STRING_FMT , new java . io . File ( io . fabric8 . maven . docker . util . VolumeBindingUtilTest . ABS_BASEDIR . getParent ( ) , io . fabric8 . maven . docker . util . PathTestUtil . stripLeadingPeriod ( io . fabric8 . maven . docker . util . VolumeBindingUtilTest . RELATIVE_PATH ) ) , io . fabric8 . maven . docker . util . VolumeBindingUtilTest . CONTAINER_PATH ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( expectedBindingString , relativizedVolumeString )", "method_name": "stripLeadingPeriod", "test_name": "testResolveParentRelativeVolumePath"}
{"focal_method": "render ( ) { return render ( new java . util . HashMap < java . lang . String , java . lang . Object > ( ) ) ; }", "test_method": "applyTest ( ) { java . lang . String [ ] [ ] tests = new java . lang . String [ ] [ ] { new java . lang . String [ ] { \"{%<sp>if<sp>1.0<sp>==<sp>1<sp>%}TRUE{%<sp>else<sp>%}FALSE{%<sp>endif<sp>%}\" , \"TRUE\" } , new java . lang . String [ ] { \"{%<sp>if<sp>nil<sp>==<sp>nil<sp>%}TRUE{%<sp>else<sp>%}FALSE{%<sp>endif<sp>%}\" , \"TRUE\" } , new java . lang . String [ ] { \"{%<sp>if<sp>false<sp>==<sp>false<sp>%}TRUE{%<sp>else<sp>%}FALSE{%<sp>endif<sp>%}\" , \"TRUE\" } , new java . lang . String [ ] { \"{%<sp>if<sp>\\\"\\\"<sp>==<sp>\\'\\'<sp>%}TRUE{%<sp>else<sp>%}FALSE{%<sp>endif<sp>%}\" , \"TRUE\" } } ; for ( java . lang . String [ ] test : tests ) { liqp . Template template = liqp . Template . parse ( test [ 0 ] ) ; java . lang . String rendered = java . lang . String . valueOf ( template . render ( ) ) ; \"<AssertPlaceHolder>\" ; } }", "assertion": "org . junit . Assert . assertThat ( rendered , org . hamcrest . CoreMatchers . is ( test [ 1 ] ) )", "method_name": "render", "test_name": "applyTest"}
{"focal_method": "typedObjectFromValueAndField ( java . lang . Object , com . pardot . rhombus . cobject . CField ) { try { return com . pardot . rhombus . util . JsonUtil . typedObjectFromValueAndFieldType ( jsonValue , field . getType ( ) ) ; } catch ( java . lang . IllegalArgumentException e ) { throw new java . lang . IllegalArgumentException ( ( ( ( ( ( ( ( \"Field<sp>\" + ( field . getName ( ) ) ) + \":<sp>Unable<sp>to<sp>convert<sp>\" ) + jsonValue ) + \"<sp>of<sp>type<sp>\" ) + ( jsonValue . getClass ( ) ) ) + \"<sp>to<sp>C*<sp>type<sp>\" ) + ( field . getType ( ) . toString ( ) ) ) ) ; } }", "test_method": "typedObjectFromDoubleAndBigint ( ) { com . pardot . rhombus . cobject . CField field = new com . pardot . rhombus . cobject . CField ( \"test\" , \"bigint\" ) ; java . lang . Double jsonValue = 1.2345678901234567E9 ; java . lang . Long expected = 1234567890L ; java . lang . Object result = com . pardot . rhombus . util . JsonUtil . typedObjectFromValueAndField ( jsonValue , field ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( expected , result )", "method_name": "typedObjectFromValueAndField", "test_name": "typedObjectFromDoubleAndBigint"}
{"focal_method": "supportsSelectDistinct ( java . lang . Object , org . teiid . query . metadata . QueryMetadataInterface , org . teiid . query . optimizer . capabilities . CapabilitiesFinder ) { return org . teiid . query . optimizer . relational . rules . CapabilitiesUtil . supports ( Capability . QUERY_SELECT_DISTINCT , modelID , metadata , capFinder ) ; }", "test_method": "testSupportsDistinct1 ( ) { org . teiid . query . metadata . TransformationMetadata metadata = org . teiid . query . unittest . RealMetadataFactory . example1Cached ( ) ; org . teiid . metadata . Schema modelID = metadata . getMetadataStore ( ) . getSchema ( \"PM1\" ) ; org . teiid . query . optimizer . capabilities . FakeCapabilitiesFinder finder = new org . teiid . query . optimizer . capabilities . FakeCapabilitiesFinder ( ) ; org . teiid . query . optimizer . capabilities . BasicSourceCapabilities sourceCaps = new org . teiid . query . optimizer . capabilities . BasicSourceCapabilities ( ) ; sourceCaps . setCapabilitySupport ( Capability . QUERY_SELECT_DISTINCT , true ) ; finder . addCapabilities ( \"pm1\" , sourceCaps ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertTrue ( org . teiid . query . optimizer . relational . rules . CapabilitiesUtil . supportsSelectDistinct ( modelID , metadata , finder ) )", "method_name": "supportsSelectDistinct", "test_name": "testSupportsDistinct1"}
{"focal_method": "getMergeFeature ( java . lang . String ) { if ( ( ! ( this . orderedBuildList . isEmpty ( ) ) ) && ( this . features . containsKey ( featureId , getLatestBuild ( ) ) ) ) { final xbdd . model . simple . Feature feature = this . features . get ( featureId , getLatestBuild ( ) ) ; final java . util . List < java . lang . String > featureStatuses = getFeatureStatuses ( feature ) ; final java . util . List < xbdd . model . MergeScenario > scenarioList = getMergedScenarios ( feature ) ; final xbdd . model . MergeFeature mergeFeature = new xbdd . model . MergeFeature ( ) ; mergeFeature . setId ( feature . getId ( ) ) ; mergeFeature . setName ( feature . getName ( ) ) ; mergeFeature . setStatuses ( featureStatuses ) ; mergeFeature . setUrl ( ( ( ( ( ( \"reports/\" + ( feature . getCoordinates ( ) . getProduct ( ) ) ) + \"/\" ) + ( feature . getCoordinates ( ) . getVersionString ( ) ) ) + \"/{{BUILD_NAME}}/\" ) + ( feature . getId ( ) ) ) ) ; mergeFeature . setScenarios ( scenarioList ) ; return mergeFeature ; } else { return null ; } }", "test_method": "noFeatureAdded ( ) { final xbdd . model . simple . Feature feature = new xbdd . model . simple . Feature ( ( ( com . mongodb . BasicDBObject ) ( com . mongodb . util . JSON . parse ( \"{'_id'<sp>:<sp>'p1/f1','id'<sp>:<sp>'f1','description'<sp>:<sp>''<sp>,'name'<sp>:<sp>'f1',<sp>'elements'<sp>:<sp>[{'id'<sp>:<sp>'e1','description'<sp>:<sp>'','name'<sp>:<sp>'e1','steps'<sp>:<sp>[{'result'<sp>:<sp>{'status'<sp>:<sp>'passed'},'name'<sp>:<sp>'e2',},{'result'<sp>:<sp>{'status'<sp>:<sp>'passed'},'name'<sp>:<sp>'e3',}],}],'coordinates'<sp>:<sp>{'product'<sp>:<sp>'P1','major'<sp>:<sp>1,'minor'<sp>:<sp>1,'servicePack'<sp>:<sp>1,'build'<sp>:<sp>'build1','version'<sp>:<sp>'1.1.1'},'calculatedStatus'<sp>:<sp>'unknown<sp>status?<sp>-<sp>expected<sp>passed,failed<sp>or<sp>undefined','originalAutomatedStatus'<sp>:<sp>'unknown<sp>status?<sp>-<sp>expected<sp>passed,failed<sp>or<sp>undefined'}\" ) ) ) ) ; final java . lang . String [ ] builds = new java . lang . String [ ] { \"build1\" , \"build2\" } ; final xbdd . util . MultipleBuildsFeatureMergeHelper target = new xbdd . util . MultipleBuildsFeatureMergeHelper ( java . util . Arrays . asList ( builds ) ) ; final xbdd . model . MergeFeature isNull = null ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertThat ( target . getMergeFeature ( feature . getId ( ) ) , org . hamcrest . Matchers . is ( isNull ) )", "method_name": "getMergeFeature", "test_name": "noFeatureAdded"}
{"focal_method": "getPropertyRaw ( java . lang . String ) { return getStateProvider ( ) . getProperty ( getNode ( ) , name ) ; }", "test_method": "disabledElement_updateIsAllowedBySynchronizeProperty_updateIsDone ( ) { com . vaadin . flow . dom . Element element = com . vaadin . flow . dom . ElementFactory . createDiv ( ) ; com . vaadin . flow . component . UI ui = new com . vaadin . flow . component . UI ( ) ; ui . getElement ( ) . appendChild ( element ) ; element . setEnabled ( false ) ; element . synchronizeProperty ( com . vaadin . flow . server . communication . rpc . MapSyncRpcHandlerTest . TEST_PROPERTY , com . vaadin . flow . server . communication . rpc . MapSyncRpcHandlerTest . DUMMY_EVENT , DisabledUpdateMode . ALWAYS ) ; com . vaadin . flow . server . communication . rpc . MapSyncRpcHandlerTest . sendSynchronizePropertyEvent ( element , ui , com . vaadin . flow . server . communication . rpc . MapSyncRpcHandlerTest . TEST_PROPERTY , com . vaadin . flow . server . communication . rpc . MapSyncRpcHandlerTest . NEW_VALUE ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( com . vaadin . flow . server . communication . rpc . MapSyncRpcHandlerTest . NEW_VALUE , element . getPropertyRaw ( com . vaadin . flow . server . communication . rpc . MapSyncRpcHandlerTest . TEST_PROPERTY ) )", "method_name": "getPropertyRaw", "test_name": "disabledElement_updateIsAllowedBySynchronizeProperty_updateIsDone"}
{"focal_method": "getErrorIndex ( ) { return errorIndex ; }", "test_method": "test_parse_french_short_strict_full_noMatch ( ) { setStrict ( true ) ; java . text . ParsePosition pos = new java . text . ParsePosition ( 0 ) ; getFormatter ( test . java . time . format . MONTH_OF_YEAR , TextStyle . SHORT ) . withLocale ( Locale . FRENCH ) . parseUnresolved ( \"janvier\" , pos ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( pos . getErrorIndex ( ) , 0 )", "method_name": "getErrorIndex", "test_name": "test_parse_french_short_strict_full_noMatch"}
{"focal_method": "evaluate ( org . xml . sax . InputSource ) { throw new java . lang . UnsupportedOperationException ( ) ; }", "test_method": "noTargetField ( ) { final org . w3c . dom . Document document = newRecord ( eu . aliada . rdfizer . pipeline . format . marc . selector . xml . A_VARIABLE_FIELD_NAME , '#' , '#' , 'a' ) ; final eu . aliada . rdfizer . pipeline . format . marc . selector . xml . VariableFieldExpression expression = new eu . aliada . rdfizer . pipeline . format . marc . selector . xml . VariableFieldExpression ( ( ( A_VARIABLE_FIELD_NAME ) + \"a\" ) ) ; expression . xpath = new eu . aliada . rdfizer . pipeline . format . xml . OXPath ( ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertNull ( expression . evaluate ( document ) )", "method_name": "evaluate", "test_name": "noTargetField"}
{"focal_method": "getXWikiContext ( ) { return xcontext ; }", "test_method": "testAuthenticateWithSuperAdminPrefixedWithXWikiWhenSuperAdminPasswordIsTurnedOff ( ) { java . security . Principal principal = this . authService . authenticate ( XWikiRightService . SUPERADMIN_USER_FULLNAME , \"whatever\" , this . oldcore . getXWikiContext ( ) ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertNull ( principal )", "method_name": "getXWikiContext", "test_name": "testAuthenticateWithSuperAdminPrefixedWithXWikiWhenSuperAdminPasswordIsTurnedOff"}
{"focal_method": "getRootDirectory ( ) { return rootDirectory ; }", "test_method": "testCacheTiming ( ) { java . lang . String filename = \"file:testCacheTiming.xml\" ; System . out . printf ( \"%s%n\" , filename ) ; java . lang . String cacheDirName = tempFolder . newFolder ( ) . getAbsolutePath ( ) ; System . out . printf ( \"cacheDir=%s%n\" , cacheDirName ) ; java . io . File cacheDir = new java . io . File ( cacheDirName ) ; org . apache . commons . io . FileUtils . deleteDirectory ( cacheDir ) ; assert ! ( cacheDir . exists ( ) ) ; ucar . nc2 . util . DiskCache2 cache = new ucar . nc2 . util . DiskCache2 ( cacheDirName , false , 0 , 0 ) ; cache . setAlwaysUseCache ( true ) ; \"<AssertPlaceHolder>\" ; assert new java . io . File ( cache . getRootDirectory ( ) ) . exists ( ) ; ucar . nc2 . ncml . Aggregation . setPersistenceCache ( cache ) ; AggregationExisting . countCacheUse = 0 ; long start = java . lang . System . currentTimeMillis ( ) ; try ( ucar . nc2 . NetcdfFile ncfile = ucar . nc2 . ncml . NcMLReader . readNcML ( new java . io . StringReader ( ncml2 ) , filename , null ) ) { System . out . printf ( \"%nTestNcmlAggExisting.open<sp>%s%n\" , filename ) ; ucar . nc2 . Variable time = ncfile . findVariable ( \"time\" ) ; System . out . printf ( \"<sp>Variable<sp>%s%n\" , time . getNameAndDimensions ( ) ) ; time . read ( ) ; } System . out . printf ( \"<sp>countCacheUse<sp>=<sp>%d%n\" , AggregationExisting . countCacheUse ) ; long took = ( java . lang . System . currentTimeMillis ( ) ) - start ; System . out . printf ( \"<sp>first<sp>took<sp>%d<sp>msecs%n\" , took ) ; AggregationExisting . countCacheUse = 0 ; start = java . lang . System . currentTimeMillis ( ) ; try ( ucar . nc2 . NetcdfFile ncfile = ucar . nc2 . ncml . NcMLReader . readNcML ( new java . io . StringReader ( ncml2 ) , filename , null ) ) { System . out . printf ( \"%nTestNcmlAggExisting.open<sp>%s%n\" , filename ) ; ucar . nc2 . Variable time = ncfile . findVariable ( \"time\" ) ; System . out . printf ( \"<sp>Variable<sp>%s%n\" , time . getNameAndDimensions ( ) ) ; time . read ( ) ; } System . out . printf ( \"<sp>countCacheUse<sp>=<sp>%d%n\" , AggregationExisting . countCacheUse ) ; took = ( java . lang . System . currentTimeMillis ( ) ) - start ; System . out . printf ( \"<sp>second<sp>took<sp>%d<sp>msecs%n\" , took ) ; }", "assertion": "org . junit . Assert . assertEquals ( cache . getRootDirectory ( ) , cacheDirName )", "method_name": "getRootDirectory", "test_name": "testCacheTiming"}
{"focal_method": "isTxConsistent ( org . bitcoinj . core . Transaction , boolean ) { boolean isActuallySpent = true ; for ( org . bitcoinj . core . TransactionOutput o : tx . getOutputs ( ) ) { if ( o . isAvailableForSpending ( ) ) { if ( o . isMineOrWatched ( this ) ) isActuallySpent = false ; if ( ( o . getSpentBy ( ) ) != null ) { org . bitcoinj . wallet . Wallet . log . error ( \"isAvailableForSpending<sp>!=<sp>spentBy\" ) ; return false ; } } else { if ( ( o . getSpentBy ( ) ) == null ) { org . bitcoinj . wallet . Wallet . log . error ( \"isAvailableForSpending<sp>!=<sp>spentBy\" ) ; return false ; } } } return isActuallySpent == isSpent ; }", "test_method": "isTxConsistentReturnsFalseAsExpected ( ) { org . bitcoinj . wallet . Wallet wallet = new org . bitcoinj . wallet . Wallet ( PARAMS ) ; org . bitcoinj . core . TransactionOutput to = createMock ( org . bitcoinj . core . TransactionOutput . class ) ; org . easymock . EasyMock . expect ( to . isAvailableForSpending ( ) ) . andReturn ( true ) ; org . easymock . EasyMock . expect ( to . isMineOrWatched ( wallet ) ) . andReturn ( true ) ; org . easymock . EasyMock . expect ( to . getSpentBy ( ) ) . andReturn ( new org . bitcoinj . core . TransactionInput ( PARAMS , null , new byte [ 0 ] ) ) ; org . bitcoinj . core . Transaction tx = org . bitcoinj . wallet . FakeTxBuilder . createFakeTxWithoutChange ( org . bitcoinj . wallet . PARAMS , to ) ; replay ( to ) ; boolean isConsistent = wallet . isTxConsistent ( tx , false ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertFalse ( isConsistent )", "method_name": "isTxConsistent", "test_name": "isTxConsistentReturnsFalseAsExpected"}
{"focal_method": "initFieldNameStrategy ( ) { info . smart_tools . smartactors . ioc . ioc . IOC . register ( info . smart_tools . smartactors . ioc . ioc . IOC . resolve ( info . smart_tools . smartactors . ioc . ioc . IOC . getKeyForKeyStorage ( ) , \"info.smart_tools.smartactors.iobject.ifield_name.IFieldName\" ) , new info . smart_tools . smartactors . ioc . resolve_by_name_ioc_with_lambda_strategy . ResolveByNameIocStrategy ( ( a ) -> { try { return new info . smart_tools . smartactors . iobject . field_name . FieldName ( ( ( java . lang . String ) ( a [ 0 ] ) ) ) ; } catch ( e ) { throw new java . lang . RuntimeException ( \"Could<sp>not<sp>create<sp>new<sp>instance<sp>of<sp>FieldName.\" ) ; } } ) ) ; }", "test_method": "checkRefCntMethod ( ) { initFieldNameStrategy ( ) ; info . smart_tools . smartactors . iobject . iobject . IObject message = mock ( info . smart_tools . smartactors . iobject . iobject . IObject . class ) ; io . netty . handler . codec . http . FullHttpRequest request = new info . smart_tools . smartactors . testing . test_http_endpoint . TestFullHttpRequest ( message ) ; \"<AssertPlaceHolder>\" ; request . refCnt ( ) ; org . junit . Assert . fail ( ) ; }", "assertion": "org . junit . Assert . assertNotNull ( request )", "method_name": "initFieldNameStrategy", "test_name": "checkRefCntMethod"}
{"focal_method": "getUserKey ( ) { return userKey ; }", "test_method": "testSetUserKey ( ) { details . setUserKey ( 12 ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( 12 , details . getUserKey ( ) )", "method_name": "getUserKey", "test_name": "testSetUserKey"}
{"focal_method": "toString ( ) { return ( ( getVerb ( ) ) + \"<sp>\" ) + ( edu . illinois . library . cantaloupe . resource . api . APITask . getUUID ( ) ) ; }", "test_method": "testGetPublicReferenceFallsBackToHTTPSRequest ( ) { java . lang . String resourceURI = \"https://example.net/cats/dogs\" ; edu . illinois . library . cantaloupe . resource . MockHttpServletRequest servletRequest = ( ( edu . illinois . library . cantaloupe . resource . MockHttpServletRequest ) ( instance . getRequest ( ) . getServletRequest ( ) ) ) ; servletRequest . setContextPath ( \"/cats\" ) ; servletRequest . setRequestURL ( resourceURI ) ; edu . illinois . library . cantaloupe . http . Reference ref = instance . getPublicReference ( ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( resourceURI , ref . toString ( ) )", "method_name": "toString", "test_name": "testGetPublicReferenceFallsBackToHTTPSRequest"}
{"focal_method": "createSample ( java . lang . String , java . lang . String , java . util . List , java . util . List , double ) { final java . lang . String suffix = ( nameSuffix == null ) ? \"\" : nameSuffix ; final java . util . List < java . lang . String > labelNames = ( additionalLabelNames == null ) ? java . util . Collections . < java . lang . String > emptyList ( ) : additionalLabelNames ; final java . util . List < java . lang . String > labelValues = ( additionalLabelValues == null ) ? java . util . Collections . < java . lang . String > emptyList ( ) : additionalLabelValues ; return new io . prometheus . client . Collector . MetricFamilySamples . Sample ( io . prometheus . client . Collector . sanitizeMetricName ( ( dropwizardName + suffix ) ) , new java . util . ArrayList < java . lang . String > ( labelNames ) , new java . util . ArrayList < java . lang . String > ( labelValues ) , value ) ; }", "test_method": "test_WHEN_MetricNameSuffixRequested_THEN_ShouldReturnCorrectSample ( ) { final java . util . Map < java . lang . String , java . lang . String > labels = new java . util . HashMap < java . lang . String , java . lang . String > ( ) ; labels . put ( \"service\" , \"${0}\" ) ; labels . put ( \"status\" , \"s_${1}\" ) ; final io . prometheus . client . dropwizard . samplebuilder . MapperConfig mapperConfig = new io . prometheus . client . dropwizard . samplebuilder . MapperConfig ( \"app.okhttpclient.client.HttpClient.*.*\" , \"${0}\" 0 , labels ) ; final java . util . List < io . prometheus . client . dropwizard . samplebuilder . MapperConfig > mapperConfigs = java . util . Arrays . asList ( new io . prometheus . client . dropwizard . samplebuilder . MapperConfig ( \"${0}\" 2 ) , mapperConfig , new io . prometheus . client . dropwizard . samplebuilder . MapperConfig ( \"app.okhttpclient.client.HttpClient.*.total\" ) ) ; final io . prometheus . client . dropwizard . samplebuilder . CustomMappingSampleBuilder converter = new io . prometheus . client . dropwizard . samplebuilder . CustomMappingSampleBuilder ( mapperConfigs ) ; final io . prometheus . client . Collector . MetricFamilySamples . Sample expectedResult = new io . prometheus . client . Collector . MetricFamilySamples . Sample ( \"app_okhttpclient_client_HttpClient_greatService_suffix\" , java . util . Arrays . asList ( \"service\" , \"status\" ) , java . util . Arrays . asList ( \"greatService\" , \"s_400\" ) , 1.0 ) ; final io . prometheus . client . Collector . MetricFamilySamples . Sample result = converter . createSample ( \"${0}\" 1 , \"_suffix\" , java . util . Collections . < java . lang . String > emptyList ( ) , java . util . Collections . < java . lang . String > emptyList ( ) , 1.0 ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( expectedResult , result )", "method_name": "createSample", "test_name": "test_WHEN_MetricNameSuffixRequested_THEN_ShouldReturnCorrectSample"}
{"focal_method": "getKind ( ) { return org . apache . flink . core . fs . FileSystemKind . OBJECT_STORE ; }", "test_method": "testS3Kind ( ) { try { java . lang . Class . forName ( \"org.apache.hadoop.fs.s3.S3FileSystem\" ) ; } catch ( java . lang . ClassNotFoundException ignored ) { log . info ( \"Skipping<sp>test<sp>'testS3Kind()'<sp>because<sp>the<sp>S3<sp>file<sp>system<sp>is<sp>not<sp>in<sp>the<sp>class<sp>path\" ) ; return ; } final org . apache . flink . core . fs . FileSystem s3 = new org . apache . flink . core . fs . Path ( \"s3://myId:mySecret@bucket/some/bucket/some/object\" ) . getFileSystem ( ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( FileSystemKind . OBJECT_STORE , s3 . getKind ( ) )", "method_name": "getKind", "test_name": "testS3Kind"}
{"focal_method": "get ( io . grpc . internal . SharedResourceHolder$Resource ) { return io . grpc . internal . SharedResourceHolder . holder . getInternal ( resource ) ; }", "test_method": "scheduledExecutorService_default ( ) { io . grpc . inprocess . InProcessChannelBuilder builder = io . grpc . inprocess . InProcessChannelBuilder . forName ( \"foo\" ) ; io . grpc . internal . ClientTransportFactory clientTransportFactory = builder . buildTransportFactory ( ) ; \"<AssertPlaceHolder>\" ; io . grpc . internal . SharedResourceHolder . release ( io . grpc . inprocess . TIMER_SERVICE , clientTransportFactory . getScheduledExecutorService ( ) ) ; clientTransportFactory . close ( ) ; }", "assertion": "org . junit . Assert . assertSame ( io . grpc . internal . SharedResourceHolder . get ( io . grpc . inprocess . TIMER_SERVICE ) , clientTransportFactory . getScheduledExecutorService ( ) )", "method_name": "get", "test_name": "scheduledExecutorService_default"}
{"focal_method": "get ( ) { java . util . concurrent . ConcurrentMap < com . github . jknack . handlebars . io . TemplateSource , java . util . concurrent . Future < org . apache . commons . lang3 . tuple . Pair < com . github . jknack . handlebars . io . TemplateSource , com . github . jknack . handlebars . Template > > > cache = new java . util . concurrent . ConcurrentHashMap ( ) ; com . github . jknack . handlebars . io . TemplateSource source = new com . github . jknack . handlebars . io . URLTemplateSource ( \"/template.hbs\" , getClass ( ) . getResource ( \"/template.hbs\" ) ) ; com . github . jknack . handlebars . Template template = createMock ( com . github . jknack . handlebars . Template . class ) ; com . github . jknack . handlebars . Parser parser = createMock ( com . github . jknack . handlebars . Parser . class ) ; expect ( parser . parse ( source ) ) . andReturn ( template ) ; replay ( parser , template ) ; org . junit . Assert . assertEquals ( template , new com . github . jknack . handlebars . cache . HighConcurrencyTemplateCache ( cache ) . get ( source , parser ) ) ; org . junit . Assert . assertEquals ( template , new com . github . jknack . handlebars . cache . HighConcurrencyTemplateCache ( cache ) . get ( source , parser ) ) ; verify ( parser , template ) ; }", "test_method": "errorShouldBeReThrow ( ) { java . util . concurrent . ConcurrentMap < com . github . jknack . handlebars . io . TemplateSource , java . util . concurrent . Future < org . apache . commons . lang3 . tuple . Pair < com . github . jknack . handlebars . io . TemplateSource , com . github . jknack . handlebars . Template > > > cache = createMock ( java . util . concurrent . ConcurrentHashMap . class ) ; com . github . jknack . handlebars . io . TemplateSource source = new com . github . jknack . handlebars . io . URLTemplateSource ( \"/template.hbs\" , getClass ( ) . getResource ( \"/template.hbs\" ) ) ; java . util . concurrent . Future < org . apache . commons . lang3 . tuple . Pair < com . github . jknack . handlebars . io . TemplateSource , com . github . jknack . handlebars . Template > > future = createMock ( java . util . concurrent . Future . class ) ; expect ( cache . get ( source ) ) . andReturn ( future ) ; expect ( future . get ( ) ) . andThrow ( new java . lang . Error ( ) ) ; com . github . jknack . handlebars . Template template = createMock ( com . github . jknack . handlebars . Template . class ) ; org . apache . commons . lang3 . tuple . Pair < com . github . jknack . handlebars . io . TemplateSource , com . github . jknack . handlebars . Template > pair = createMock ( org . apache . commons . lang3 . tuple . Pair . class ) ; expect ( pair . getLeft ( ) ) . andReturn ( source ) ; expect ( pair . getValue ( ) ) . andReturn ( template ) ; expect ( cache . get ( source ) ) . andReturn ( future ) ; expect ( future . get ( ) ) . andReturn ( pair ) . times ( 2 ) ; com . github . jknack . handlebars . Parser parser = createMock ( com . github . jknack . handlebars . Parser . class ) ; replay ( parser , template , cache , future , pair ) ; \"<AssertPlaceHolder>\" ; verify ( parser , template , cache , future , pair ) ; }", "assertion": "org . junit . Assert . assertEquals ( template , new com . github . jknack . handlebars . cache . HighConcurrencyTemplateCache ( cache ) . get ( source , parser ) )", "method_name": "get", "test_name": "errorShouldBeReThrow"}
{"focal_method": "getMessageDelivery ( java . lang . Long ) { return dataObjectService . find ( org . kuali . rice . kcb . bo . MessageDelivery . class , id ) ; }", "test_method": "testInvalidRead ( ) { org . kuali . rice . kcb . bo . MessageDelivery m = messageDeliveryService . getMessageDelivery ( java . lang . Long . valueOf ( ( - 1 ) ) ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertNull ( m )", "method_name": "getMessageDelivery", "test_name": "testInvalidRead"}
{"focal_method": "isCancelled ( ) { return _future . isCancelled ( ) ; }", "test_method": "testRPCWithCancellation ( ) { io . netty . channel . ChannelPipeline channelPipeline = _embeddedChannel . pipeline ( ) ; channelPipeline . addFirst ( new io . netty . channel . ChannelOutboundHandlerAdapter ( ) { @ com . liferay . portal . fabric . netty . rpc . Override public void write ( io . netty . channel . ChannelHandlerContext channelHandlerContext , java . lang . Object object , io . netty . channel . ChannelPromise channelPromise ) { channelPromise . cancel ( true ) ; } } ) ; java . util . concurrent . Future < java . lang . String > future = com . liferay . portal . fabric . netty . rpc . RPCUtil . execute ( _embeddedChannel , new com . liferay . portal . fabric . netty . rpc . RPCUtilTest . ResultRPCCallable ( \"result\" ) ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertTrue ( future . isCancelled ( ) )", "method_name": "isCancelled", "test_name": "testRPCWithCancellation"}
{"focal_method": "getN ( ) { return this . nobs ; }", "test_method": "test20090720 ( ) { org . apache . commons . math4 . stat . descriptive . DescriptiveStatistics descriptiveStatistics = new org . apache . commons . math4 . stat . descriptive . DescriptiveStatistics ( 100 ) ; for ( int i = 0 ; i < 161 ; i ++ ) { descriptiveStatistics . addValue ( 1.2 ) ; } descriptiveStatistics . clear ( ) ; descriptiveStatistics . addValue ( 1.2 ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( 1 , descriptiveStatistics . getN ( ) )", "method_name": "getN", "test_name": "test20090720"}
{"focal_method": "find ( ) { return criteriaBuilderFactory . get ( ) ; }", "test_method": "shouldReturnCriteriaBuilder ( ) { com . qcadoo . model . api . types . BelongsToType fieldType = mock ( com . qcadoo . model . api . types . BelongsToType . class ) ; com . qcadoo . model . internal . api . InternalDataDefinition dataDefinition = mock ( com . qcadoo . model . internal . api . InternalDataDefinition . class , com . qcadoo . model . internal . RETURNS_DEEP_STUBS ) ; given ( fieldType . getDataDefinition ( ) ) . willReturn ( dataDefinition ) ; com . qcadoo . model . api . FieldDefinition fieldDefinition = mock ( com . qcadoo . model . api . FieldDefinition . class ) ; given ( fieldDefinition . getType ( ) ) . willReturn ( fieldType ) ; given ( fieldDefinition . getName ( ) ) . willReturn ( \"field\" ) ; given ( dataDefinition . getField ( \"tree\" ) ) . willReturn ( fieldDefinition ) ; com . qcadoo . model . api . search . SearchCriteriaBuilder searchCriteriaBuilder = mock ( com . qcadoo . model . api . search . SearchCriteriaBuilder . class ) ; given ( dataDefinition . find ( ) . createAlias ( fieldDefinition . getName ( ) , fieldDefinition . getName ( ) ) . add ( com . qcadoo . model . api . search . SearchRestrictions . eq ( ( ( fieldDefinition . getName ( ) ) + \".id\" ) , 1L ) ) ) . willReturn ( searchCriteriaBuilder ) ; com . qcadoo . model . api . EntityList list = new com . qcadoo . model . internal . EntityListImpl ( dataDefinition , \"tree\" , 1L ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( searchCriteriaBuilder , list . find ( ) )", "method_name": "find", "test_name": "shouldReturnCriteriaBuilder"}
{"focal_method": "applyRule ( java . lang . String ) { uk . co . hadoopathome . kafkastreams . drools . Message message = new uk . co . hadoopathome . kafkastreams . drools . Message ( value ) ; uk . co . hadoopathome . kafkastreams . drools . DroolsRulesApplier . KIE_SESSION . insert ( message ) ; uk . co . hadoopathome . kafkastreams . drools . DroolsRulesApplier . KIE_SESSION . fireAllRules ( ) ; return message . getContent ( ) ; }", "test_method": "testRuleNotTriggered ( ) { uk . co . hadoopathome . kafkastreams . drools . DroolsRulesApplier rulesApplier = new uk . co . hadoopathome . kafkastreams . drools . DroolsRulesApplier ( \"IfContainsEPrepend0KS\" ) ; java . lang . String output = rulesApplier . applyRule ( \"canal\" ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( \"canal\" , output )", "method_name": "applyRule", "test_name": "testRuleNotTriggered"}
{"focal_method": "getATime ( ) { guard ( org . dcache . nfs . vfs . Stat . StatAttribute . ATIME ) ; return _atime ; }", "test_method": "testGetATime ( ) { org . dcache . nfs . vfs . Stat stat = new org . dcache . nfs . vfs . Stat ( ) ; stat . setATime ( 1 ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( 1 , stat . getATime ( ) )", "method_name": "getATime", "test_name": "testGetATime"}
{"focal_method": "getAgentId ( io . nuls . kernel . model . NulsDigestData ) { java . lang . String hashHex = hash . getDigestHex ( ) ; return hashHex . substring ( ( ( hashHex . length ( ) ) - 8 ) ) . toUpperCase ( ) ; }", "test_method": "getAgentId ( ) { io . nuls . kernel . model . NulsDigestData hash = io . nuls . kernel . model . NulsDigestData . calcDigestData ( \"123123\" . getBytes ( ) ) ; System . out . println ( io . nuls . consensus . poc . protocol . util . PoConvertUtil . getAgentId ( hash ) ) ; System . out . println ( hash ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertTrue ( true )", "method_name": "getAgentId", "test_name": "getAgentId"}
{"focal_method": "getSelection ( ) { checkWidget ( ) ; org . eclipse . nebula . widgets . grid . GridItem [ ] result = new org . eclipse . nebula . widgets . grid . GridItem [ 0 ] ; if ( cellSelectionEnabled ) { } else { result = selectedItems . toArray ( new org . eclipse . nebula . widgets . grid . GridItem [ selectedItems . size ( ) ] ) ; } return result ; }", "test_method": "testHandleSetSelection_multi ( ) { handler = new org . eclipse . swt . internal . widgets . treekit . TreeOperationHandler ( tree ) ; org . eclipse . swt . internal . widgets . treekit . TreeOperationHandler_Test . createTreeItems ( tree , 3 ) ; org . eclipse . swt . widgets . TreeItem item1 = tree . getItem ( 0 ) ; org . eclipse . swt . widgets . TreeItem item2 = tree . getItem ( 2 ) ; org . eclipse . rap . json . JsonArray selection = new org . eclipse . rap . json . JsonArray ( ) . add ( getId ( item1 ) ) . add ( getId ( item2 ) ) ; handler . handleSet ( new org . eclipse . rap . json . JsonObject ( ) . add ( \"selection\" , selection ) ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertArrayEquals ( new org . eclipse . swt . widgets . TreeItem [ ] { item1 , item2 } , tree . getSelection ( ) )", "method_name": "getSelection", "test_name": "testHandleSetSelection_multi"}
{"focal_method": "receiverMessageFromLink ( java . lang . String ) { com . microsoft . azure . sdk . iot . deps . transport . amqp . AmqpMessage result ; if ( ( linkName == null ) || ( linkName . isEmpty ( ) ) ) { result = null ; } else if ( ( this . receiverLink ) == null ) { result = null ; } else { com . microsoft . azure . sdk . iot . deps . transport . amqp . Delivery delivery = this . receiverLink . current ( ) ; if ( ( ( ( linkName . equals ( this . receiverLinkTag ) ) && ( delivery != null ) ) && ( delivery . isReadable ( ) ) ) && ( ! ( delivery . isPartial ( ) ) ) ) { int size = delivery . pending ( ) ; byte [ ] buffer = new byte [ size ] ; int read = this . receiverLink . recv ( buffer , 0 , buffer . length ) ; this . receiverLink . advance ( ) ; result = new com . microsoft . azure . sdk . iot . deps . transport . amqp . AmqpMessage ( ) ; result . decode ( buffer , 0 , read ) ; } else { result = null ; } } return result ; }", "test_method": "ReceiverMessageFromLinkReceiverLinkNull ( ) { com . microsoft . azure . sdk . iot . deps . transport . amqp . AmqpDeviceOperations amqpDeviceOperation = new com . microsoft . azure . sdk . iot . deps . transport . amqp . AmqpDeviceOperations ( ) ; new mockit . NonStrictExpectations ( ) { { } } ; com . microsoft . azure . sdk . iot . deps . transport . amqp . AmqpMessage result = amqpDeviceOperation . receiverMessageFromLink ( tests . unit . com . microsoft . azure . sdk . iot . deps . transport . amqp . AmqpDeviceOperationsTest . TEST_SENDER_LINK_NAME ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertNull ( result )", "method_name": "receiverMessageFromLink", "test_name": "ReceiverMessageFromLinkReceiverLinkNull"}
{"focal_method": "getStylesSource ( ) { return this . stylesSource ; }", "test_method": "testLoadSaveLoad ( ) { try ( org . apache . poi . xssf . usermodel . XSSFWorkbook workbook = org . apache . poi . xssf . XSSFTestDataSamples . openSampleWorkbook ( org . apache . poi . xssf . model . TestStylesTable . testFile ) ) { \"<AssertPlaceHolder>\" ; org . apache . poi . xssf . model . StylesTable st = workbook . getStylesSource ( ) ; doTestExisting ( st ) ; st = org . apache . poi . xssf . XSSFTestDataSamples . writeOutAndReadBack ( workbook ) . getStylesSource ( ) ; doTestExisting ( st ) ; } }", "assertion": "org . junit . Assert . assertNotNull ( workbook . getStylesSource ( ) )", "method_name": "getStylesSource", "test_name": "testLoadSaveLoad"}
{"focal_method": "readDouble ( java . io . File ) { return new java . io . DataInputStream ( new java . io . FileInputStream ( file ) ) . readDouble ( ) ; }", "test_method": "shouldWriteDoubleToFile ( ) { tdd . junit . FileWriter writer = null ; java . io . File file = null ; try { file = java . io . File . createTempFile ( \"FileWriterTest\" , \"\" ) ; writer = new tdd . junit . FileWriter ( file ) ; writer . writeDouble ( 40.4 ) ; \"<AssertPlaceHolder>\" ; } finally { closeWriter ( writer ) ; deleteFile ( file ) ; } }", "assertion": "org . junit . Assert . assertEquals ( 40.4 , readDouble ( file ) , 0 )", "method_name": "readDouble", "test_name": "shouldWriteDoubleToFile"}
{"focal_method": "getData ( ) { return data ; }", "test_method": "testGetData ( ) { com . eclipsesource . tabris . ui . PageData data = mock ( com . eclipsesource . tabris . ui . PageData . class ) ; webPage = new com . eclipsesource . tabris . internal . ui . web . WebPage ( ui , uiRenderer , descriptor , data ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertSame ( data , webPage . getData ( ) )", "method_name": "getData", "test_name": "testGetData"}
{"focal_method": "toString ( ) { final int maxLen = 10 ; java . lang . StringBuilder builder = new java . lang . StringBuilder ( ) ; builder . append ( \"DataProfile<sp>[file=\" ) . append ( file ) . append ( \",<sp>domainObject=\" ) . append ( domainObject ) . append ( \",<sp>irodsTagValues=\" 1 ) . append ( ( ( metadata ) != null ? metadata . subList ( 0 , java . lang . Math . min ( metadata . size ( ) , maxLen ) ) : null ) ) . append ( \",<sp>acls=\" ) . append ( ( ( acls ) != null ? acls . subList ( 0 , java . lang . Math . min ( acls . size ( ) , maxLen ) ) : null ) ) . append ( \",<sp>isStarred=\" ) . append ( isStarred ) . append ( \",<sp>isShared=\" ) . append ( isShared ) . append ( \",<sp>mimeType=\" ) . append ( mimeType ) . append ( \",<sp>irodsTagValues=\" 0 ) . append ( infoType ) . append ( \",<sp>irodsTagValues=\" ) . append ( ( ( irodsTagValues ) != null ? irodsTagValues . subList ( 0 , java . lang . Math . min ( irodsTagValues . size ( ) , maxLen ) ) : null ) ) . append ( \",<sp>parentPath=\" ) . append ( parentPath ) . append ( \",<sp>irodsTagValues=\" 2 ) . append ( childName ) . append ( \",<sp>pathComponents=\" ) . append ( ( ( pathComponents ) != null ? pathComponents . subList ( 0 , java . lang . Math . min ( pathComponents . size ( ) , maxLen ) ) : null ) ) . append ( \"]\" ) ; return builder . toString ( ) ; }", "test_method": "testModifyUserTypeCheckXML ( ) { java . lang . String userName = \"test\" ; org . irods . jargon . core . protovalues . UserTypeEnum userType = org . irods . jargon . core . protovalues . UserTypeEnum . RODS_ADMIN ; org . irods . jargon . core . packinstr . GeneralAdminInp pi = org . irods . jargon . core . packinstr . GeneralAdminInp . instanceForModifyUserType ( userName , userType ) ; java . lang . String tagOut = pi . getParsedTags ( ) ; java . lang . StringBuilder sb = new java . lang . StringBuilder ( ) ; sb . append ( \"<generalAdminInp_PI><arg0>modify</arg0>\\n\" ) ; sb . append ( \"<arg1>user</arg1>\\n\" ) ; sb . append ( \"<arg2>test</arg2>\\n\" ) ; sb . append ( \"<arg3>type</arg3>\\n\" ) ; sb . append ( \"<arg4>rodsadmin</arg4>\\n\" ) ; sb . append ( \"<arg5></arg5>\\n\" ) ; sb . append ( \"<arg6></arg6>\\n\" ) ; sb . append ( \"<arg3>type</arg3>\\n\" 0 ) ; sb . append ( \"<arg3>type</arg3>\\n\" 1 ) ; sb . append ( \"<arg9></arg9>\\n\" ) ; sb . append ( \"</generalAdminInp_PI>\\n\" ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( \"<arg3>type</arg3>\\n\" 2 , sb . toString ( ) , tagOut )", "method_name": "toString", "test_name": "testModifyUserTypeCheckXML"}
{"focal_method": "close ( ) { input . close ( ) ; }", "test_method": "recordAndVerifyWithMixedCascadeLevels ( mockit . CascadingParametersTest$SocketFactory ) { new mockit . Expectations ( ) { { sf . createSocket ( \"first\" , 80 ) . getKeepAlive ( ) ; result = true ; sf . createSocket ( \"second\" , anyInt ) . getChannel ( ) . close ( ) ; times = 1 ; } } ; sf . createSocket ( \"second\" , 80 ) . getChannel ( ) . close ( ) ; \"<AssertPlaceHolder>\" ; sf . createSocket ( \"first\" , 8080 ) . getChannel ( ) . provider ( ) . openPipe ( ) ; new mockit . Verifications ( ) { { sf . createSocket ( \"first\" , 8080 ) . getChannel ( ) . provider ( ) . openPipe ( ) ; } } ; }", "assertion": "org . junit . Assert . assertTrue ( sf . createSocket ( \"first\" , 80 ) . getKeepAlive ( ) )", "method_name": "close", "test_name": "recordAndVerifyWithMixedCascadeLevels"}
{"focal_method": "configureWhiteList ( com . intel . mtwilson . TxtHostRecord ) { java . lang . String result = text ( httpPost ( msurl ( \"/host/whitelist\" ) , toJSON ( hostObj ) ) ) ; return \"true\" . equals ( result ) ; }", "test_method": "testAddIntelHost ( ) { java . util . List < com . intel . mtwilson . datatypes . ConnectionString > hosts = com . intel . mtwilson . My . env ( ) . getHostConnectionList ( ) ; java . util . List < com . intel . mtwilson . datatypes . ConnectionString > intel = getVendorHosts ( hosts , Vendor . INTEL ) ; if ( intel . isEmpty ( ) ) { throw new java . lang . IllegalArgumentException ( \"No<sp>Intel<sp>hosts<sp>in<sp>your<sp>environment\" ) ; } for ( com . intel . mtwilson . datatypes . ConnectionString conn : intel ) { try { System . out . println ( ( \"Adding<sp>\" + conn ) ) ; com . intel . mtwilson . datatypes . TxtHostRecord gkvHost = new com . intel . mtwilson . datatypes . TxtHostRecord ( ) ; gkvHost . HostName = conn . getManagementServerName ( ) ; gkvHost . AddOn_Connection_String = conn . getConnectionStringWithPrefix ( ) ; com . intel . mtwilson . datatypes . HostConfigData hostdata = new com . intel . mtwilson . datatypes . HostConfigData ( ) ; hostdata . setRegisterHost ( false ) ; hostdata . setTxtHostRecord ( gkvHost ) ; boolean success = com . intel . mtwilson . My . client ( ) . configureWhiteList ( hostdata ) ; \"<AssertPlaceHolder>\" ; } catch ( test . api . ApiException e ) { if ( ( e . getErrorCode ( ) ) == ( ErrorCode . MS_HOST_COMMUNICATION_ERROR . getErrorCode ( ) ) ) { System . err . println ( ( ( ( \"Cannot<sp>add<sp>host<sp><\" + ( conn . getConnectionStringWithPrefix ( ) ) ) + \">:<sp>\" ) + ( e . getMessage ( ) ) ) ) ; } } } }", "assertion": "org . junit . Assert . assertTrue ( success )", "method_name": "configureWhiteList", "test_name": "testAddIntelHost"}
{"focal_method": "extractStartTime ( ucar . nc2 . NetcdfFile ) { return org . esa . beam . binning . reader . BinnedProductReader . extractTime ( netcdfFile , \"time_coverage_start\" ) ; }", "test_method": "testExtractStartTime_NoTimeInfo ( ) { final java . net . URL resource = getClass ( ) . getResource ( \"test_without_time_info.nc\" ) ; final ucar . nc2 . NetcdfFile netcdfFile = ucar . nc2 . NetcdfFile . openInMemory ( resource . toURI ( ) ) ; org . esa . beam . framework . datamodel . ProductData . UTC startTime = org . esa . beam . binning . reader . BinnedProductReader . extractStartTime ( netcdfFile ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertNull ( startTime )", "method_name": "extractStartTime", "test_name": "testExtractStartTime_NoTimeInfo"}
{"focal_method": "valueOf ( long ) { return new org . postgresql . replication . LogSequenceNumber ( value ) ; }", "test_method": "testEqualLSN ( ) { org . postgresql . replication . LogSequenceNumber first = org . postgresql . replication . LogSequenceNumber . valueOf ( \"0/15D690F8\" ) ; org . postgresql . replication . LogSequenceNumber second = org . postgresql . replication . LogSequenceNumber . valueOf ( \"0/15D690F8\" ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertThat ( first , org . hamcrest . CoreMatchers . equalTo ( second ) )", "method_name": "valueOf", "test_name": "testEqualLSN"}
{"focal_method": "back ( ) { if ( ( org . eclipse . swt . chromium . Chromium . lib ) == null ) { org . eclipse . swt . SWT . error ( SWT . ERROR_FAILED_LOAD_LIBRARY ) ; } if ( canGoBack ) { org . eclipse . swt . chromium . Chromium . lib . cefswt_go_back ( browser ) ; return true ; } return false ; }", "test_method": "test_back ( ) { for ( int i = 0 ; i < 2 ; i ++ ) { browser . back ( ) ; } boolean result = browser . back ( ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertFalse ( result )", "method_name": "back", "test_name": "test_back"}
{"focal_method": "saveAll ( java . lang . Iterable ) { org . springframework . util . Assert . notNull ( entities , \"Entities<sp>must<sp>not<sp>be<sp>null!\" ) ; return saveAll ( reactor . core . publisher . Flux . fromIterable ( entities ) ) ; }", "test_method": "shouldSaveIterableEntities ( ) { java . lang . String documentId = randomNumeric ( 5 ) ; org . springframework . data . elasticsearch . entities . SampleEntity sampleEntity1 = new org . springframework . data . elasticsearch . entities . SampleEntity ( ) ; sampleEntity1 . setId ( documentId ) ; sampleEntity1 . setMessage ( \"hello<sp>world.\" ) ; sampleEntity1 . setVersion ( java . lang . System . currentTimeMillis ( ) ) ; java . lang . String documentId2 = randomNumeric ( 5 ) ; org . springframework . data . elasticsearch . entities . SampleEntity sampleEntity2 = new org . springframework . data . elasticsearch . entities . SampleEntity ( ) ; sampleEntity2 . setId ( documentId2 ) ; sampleEntity2 . setMessage ( \"hello<sp>world.\" ) ; sampleEntity2 . setVersion ( java . lang . System . currentTimeMillis ( ) ) ; java . lang . Iterable < org . springframework . data . elasticsearch . entities . SampleEntity > sampleEntities = java . util . Arrays . asList ( sampleEntity1 , sampleEntity2 ) ; repository . saveAll ( sampleEntities ) ; org . springframework . data . domain . Page < org . springframework . data . elasticsearch . entities . SampleEntity > entities = repository . search ( termQuery ( \"id\" , documentId ) , org . springframework . data . domain . PageRequest . of ( 0 , 50 ) ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertNotNull ( entities )", "method_name": "saveAll", "test_name": "shouldSaveIterableEntities"}
{"focal_method": "createClusterStatsRequestBuilder ( com . liferay . portal . search . engine . adapter . cluster . StatsClusterRequest ) { org . elasticsearch . action . admin . cluster . stats . ClusterStatsRequestBuilder clusterStatsRequestBuilder = ClusterStatsAction . INSTANCE . newRequestBuilder ( _elasticsearchClientResolver . getClient ( ) ) ; return clusterStatsRequestBuilder ; }", "test_method": "testClusterRequestTranslation ( ) { com . liferay . portal . search . engine . adapter . cluster . StatsClusterRequest statsClusterRequest = new com . liferay . portal . search . engine . adapter . cluster . StatsClusterRequest ( new java . lang . String [ ] { com . liferay . portal . search . elasticsearch6 . internal . search . engine . adapter . cluster . StatsClusterRequestExecutorTest . _INDEX_NAME } ) ; com . liferay . portal . search . elasticsearch6 . internal . search . engine . adapter . cluster . StatsClusterRequestExecutorImpl statsClusterRequestExecutorImpl = new com . liferay . portal . search . elasticsearch6 . internal . search . engine . adapter . cluster . StatsClusterRequestExecutorImpl ( ) { { setElasticsearchClientResolver ( _elasticsearchFixture ) ; } } ; org . elasticsearch . action . admin . cluster . stats . ClusterStatsRequestBuilder clusterStatsRequestBuilder = statsClusterRequestExecutorImpl . createClusterStatsRequestBuilder ( statsClusterRequest ) ; org . elasticsearch . action . admin . cluster . stats . ClusterStatsRequest clusterStatsRequest = clusterStatsRequestBuilder . request ( ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertNotNull ( clusterStatsRequest )", "method_name": "createClusterStatsRequestBuilder", "test_name": "testClusterRequestTranslation"}
{"focal_method": "toString ( ) { return java . lang . String . format ( \"%s,<sp>%s\" , rounds ( latitudeWGS84 , 4 ) , rounds ( longitudeWGS84 , 4 ) ) ; }", "test_method": "testToString ( ) { java . lang . String expResult = \"47.4212,<sp>10.9863\" ; java . lang . String result = de . nx42 . maps4cim . util . gis . CoordinateTest . instance . toString ( ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( expResult , result )", "method_name": "toString", "test_name": "testToString"}
{"focal_method": "size ( ) { return rows . size ( ) ; }", "test_method": "graph_union_1q ( ) { java . util . List < org . apache . jena . sparql . engine . binding . Binding > results = exec ( ( ( \"(graph<sp><\" + ( Quad . unionGraph . getURI ( ) ) ) + \"><sp>(bgp<sp>(<s2><sp>?p<sp>?o)))\" ) , org . apache . jena . sparql . core . TestSpecialGraphNames . Mode . QUADS ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( 2 , results . size ( ) )", "method_name": "size", "test_name": "graph_union_1q"}
{"focal_method": "isHidden ( ) { throw new java . lang . UnsupportedOperationException ( ) ; }", "test_method": "testRefreshLayoutMainInitial ( ) { org . talend . components . jira . tjiraoutput . TJiraOutputProperties properties = new org . talend . components . jira . tjiraoutput . TJiraOutputProperties ( \"root\" ) ; properties . init ( ) ; properties . refreshLayout ( properties . getForm ( Form . MAIN ) ) ; boolean deleteSubtasksHidden = properties . getForm ( Form . ADVANCED ) . getWidget ( \"deleteSubtasks\" ) . isHidden ( ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertTrue ( deleteSubtasksHidden )", "method_name": "isHidden", "test_name": "testRefreshLayoutMainInitial"}
{"focal_method": "toString ( ) { return ( ( ( ( ( ( ( ( ( ( ( \"Exam<sp>[id=\" + ( id ) ) + \",<sp>examNumber=\" ) + ( examNumber ) ) + \",<sp>isAnswer=\" ) + ( isAnswer ) ) + \",<sp>answerArray=\" ) + ( java . util . Arrays . toString ( answerArray ) ) ) + \",<sp>isRight=\" ) + ( isRight ) ) + \",<sp>isSubject=\" ) + ( isSubject ) ) + \"]\" ; }", "test_method": "toStringTest2 ( ) { java . lang . String str = \"{\\\"test\\\":\\\"关于开展2018年度“文明集体”、“文明职工”评选表彰活动的通知\\\"}\" ; cn . hutool . json . JSONObject json = new cn . hutool . json . JSONObject ( str ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( str , json . toString ( ) )", "method_name": "toString", "test_name": "toStringTest2"}
{"focal_method": "isEmpty ( ) { return false ; }", "test_method": "upgradeV8TOV9 ( ) { java . util . List < com . streamsets . pipeline . api . Config > configs = new java . util . ArrayList ( 1 ) ; configs . add ( new com . streamsets . pipeline . api . Config ( \"oracleCDCConfigBean.queryTimeout\" , 10 ) ) ; configs = new com . streamsets . pipeline . stage . origin . jdbc . cdc . oracle . OracleCDCSourceUpgrader ( ) . upgrade ( \"a\" , \"b\" , \"v\" , 8 , 9 , configs ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertTrue ( configs . isEmpty ( ) )", "method_name": "isEmpty", "test_name": "upgradeV8TOV9"}
{"focal_method": "get ( ) { return this . t ; }", "test_method": "shouldSupportConfigurationOfRegistryBuilder ( ) { final org . apache . tinkerpop . gremlin . driver . ser . GraphBinaryMessageSerializerV1 serializer = new org . apache . tinkerpop . gremlin . driver . ser . GraphBinaryMessageSerializerV1 ( ) ; final java . util . Map < java . lang . String , java . lang . Object > config = new java . util . HashMap ( ) ; int counter = org . apache . tinkerpop . gremlin . driver . ser . binary . GraphBinaryMessageSerializerV1Test . SampleTypeSerializerRegistryBuilder . createCounter . get ( ) ; config . put ( GraphBinaryMessageSerializerV1 . TOKEN_BUILDER , \"org.apache.tinkerpop.gremlin.driver.ser.binary.GraphBinaryMessageSerializerV1Test$SampleTypeSerializerRegistryBuilder\" ) ; serializer . configure ( config , null ) ; counter = ( org . apache . tinkerpop . gremlin . driver . ser . binary . GraphBinaryMessageSerializerV1Test . SampleTypeSerializerRegistryBuilder . createCounter . get ( ) ) - counter ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertEquals ( 1 , counter )", "method_name": "get", "test_name": "shouldSupportConfigurationOfRegistryBuilder"}
{"focal_method": "visibleFileTry ( java . lang . String [ ] ) { try { return _getProjects ( ) . isVisible ( files ) ; } catch ( java . lang . Exception e ) { _getProjects ( ) . setFocus ( ) ; try { java . lang . String [ ] parents = java . util . Arrays . copyOfRange ( files , 0 , ( ( files . length ) - 1 ) ) ; _getProjects ( ) . expand ( parents ) ; _getProjects ( ) . contextMenu ( com . liferay . ide . ui . liferay . action . REFRESH , parents ) ; ide . sleep ( 2000 ) ; } catch ( java . lang . Exception e1 ) { } for ( int i = ( files . length ) - 1 ; i > 0 ; i -- ) { java . lang . String [ ] parents = java . util . Arrays . copyOfRange ( files , 0 , ( ( files . length ) - i ) ) ; org . eclipse . swtbot . swt . finder . widgets . SWTBotTreeItem parent = _getProjects ( ) . getTreeItem ( parents ) ; _getProjects ( ) . expand ( parents ) ; java . lang . String subnode = files [ ( ( files . length ) - i ) ] ; _jobAction . waitForSubnode ( parent , subnode , com . liferay . ide . ui . liferay . action . REFRESH ) ; } return _getProjects ( ) . isVisible ( files ) ; } }", "test_method": "createActivator ( ) { wizardAction . openNewLiferayModuleWizard ( ) ; wizardAction . newModule . prepareGradle ( project . getName ( ) , com . liferay . ide . ui . module . tests . ACTIVATOR ) ; wizardAction . finish ( ) ; jobAction . waitForNoRunningJobs ( ) ; viewAction . project . refreshGradleProject ( com . liferay . ide . ui . module . tests . NewModuleProjectWizardLiferayWorkspaceGradleTests . liferayWorkspace . getName ( ) ) ; \"<AssertPlaceHolder>\" ; viewAction . project . closeAndDeleteFromDisk ( com . liferay . ide . ui . module . tests . NewModuleProjectWizardLiferayWorkspaceGradleTests . liferayWorkspace . getModuleFiles ( project . getName ( ) ) ) ; }", "assertion": "org . junit . Assert . assertTrue ( viewAction . project . visibleFileTry ( com . liferay . ide . ui . module . tests . NewModuleProjectWizardLiferayWorkspaceGradleTests . liferayWorkspace . getModuleFiles ( project . getName ( ) ) ) )", "method_name": "visibleFileTry", "test_name": "createActivator"}
{"focal_method": "recordedDirectories ( ) { return existing ; }", "test_method": "recordPathRecordsProperly ( ) { java . nio . file . Path path = java . nio . file . Paths . get ( \"foo\" , \"bar\" ) ; com . facebook . buck . util . unarchive . DirectoryCreator creator = new com . facebook . buck . util . unarchive . DirectoryCreator ( filesystem ) ; creator . recordPath ( path ) ; \"<AssertPlaceHolder>\" ; }", "assertion": "org . junit . Assert . assertTrue ( creator . recordedDirectories ( ) . contains ( java . nio . file . Paths . get ( \"foo\" , \"bar\" ) ) )", "method_name": "recordedDirectories", "test_name": "recordPathRecordsProperly"}
{"focal_method": "doMove ( java . lang . String , java . lang . String ) { try { fileService . doMoveFiles ( destPathId , params ) ; return buildOkResponse ( ) ; } catch ( java . io . FileNotFoundException e ) { org . pentaho . platform . web . http . api . resources . FileResource . logger . error ( org . pentaho . platform . web . http . messages . Messages . getInstance ( ) . getErrorString ( \"FileResource.DESTINATION_PATH_UNKNOWN\" , destPathId ) , e ) ; return buildStatusResponse ( Response . Status . NOT_FOUND ) ; } catch ( org . pentaho . platform . api . repository2 . unified . UnifiedRepositoryAccessDeniedException e ) { org . pentaho . platform . web . http . api . resources . FileResource . logger . error ( org . pentaho . platform . web . http . messages . Messages . getInstance ( ) . getErrorString ( \"FileResource.FILE_MOVE_ACCESS_DENIED\" , params ) , e ) ; return buildStatusResponse ( Response . Status . FORBIDDEN ) ; } catch ( java . lang . Throwable t ) { org . pentaho . platform . web . http . api . resources . FileResource . logger . error ( org . pentaho . platform . web . http . messages . Messages . getInstance ( ) . getString ( \"SystemResource.FILE_MOVE_FAILED\" ) , t ) ; return buildStatusResponse ( Response . Status . INTERNAL_SERVER_ERROR ) ; } }", "test_method": "testDoMove ( ) { java . lang . String params = \"params\" ; doNothing ( ) . when ( fileResource . fileService ) . doMoveFiles ( org . pentaho . platform . web . http . api . resources . FileResourceTest . PATH_ID , params ) ; javax . ws . rs . core . Response mockResponse = mock ( javax . ws . rs . core . Response . class ) ; doReturn ( mockResponse ) . when ( fileResource ) . buildOkResponse ( ) ; javax . ws . rs . core . Response testResponse = fileResource . doMove ( org . pentaho . platform . web . http . api . resources . FileResourceTest . PATH_ID , params ) ; \"<AssertPlaceHolder>\" ; verify ( fileResource . fileService , times ( 1 ) ) . doMoveFiles ( org . pentaho . platform . web . http . api . resources . FileResourceTest . PATH_ID , params ) ; verify ( fileResource , times ( 1 ) ) . buildOkResponse ( ) ; }", "assertion": "org . junit . Assert . assertEquals ( mockResponse , testResponse )", "method_name": "doMove", "test_name": "testDoMove"}